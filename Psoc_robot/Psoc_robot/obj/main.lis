 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 112
 0000           ; //****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; //  FILENAME: main.c
 0000           ; //   Made for project 2 in the second semester of school
 0000           ; //
 0000           ; //  DESCRIPTION: Main file of the Psoc_robot project.
 0000           ; //
 0000           ; //-----------------------------------------------------------------------------
 0000           ; // 
 0000           ; //*****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; ////***************************************************************************************
 0000           ; 
 0000           ; //------------------------------------------------------------------------------
 0000           ; // Name: Psoc_robot
 0000           ; //------------------------------------------------------------------------------
 0000           ; //------------------------------------------------------------------------------
 0000           ; // For Device: CY8C29466
 0000           ; //------------------------------------------------------------------------------
 0000           ; // Required Software:  PSoC Designer 5.3
 0000           ; 
 0000           ; // Project Settings: 
 0000           ; //      
 0000           ; //      Power Setting [Vcc/SysClk Freq]:  5.0V/24MHz
 0000           ; //      CPU Clock:                        Sysclk/1  
 0000           ; //      VC1                               Sysclk/12
 0000           ; //      VC2                               VC1/2 = Sysclk/24
 0000           ; //      
 0000           ; //            Timer:                          `                         For reading one joystick channel      
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareType                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_0
 0000           ; 
 0000           ; //    Timer2:                         `                         For reading one joystick channel      
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareType                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_1
 0000           ; //    
 0000           ; //      Timer3:                               `                         For reading the  ultrasonic sensor
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareTy pe                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_3
 0000           ; //            
 0000           ; //            
 0000           ; //    Pwm conected to port                 Port_0_4
 0000           ; //    PWM:                                                               For controlling one motor on one side
 0000           ; //      Clock                              VC2
 0000           ; //      Enable                             High
 0000           ; //      Period                             1000
 0000           ; //      PulseWidth                         0
 0000           ; //      CompareType                        Less than 
 0000           ; //      Interrupt Type                     Terminal count
 0000           ; //      LCD:
 0000           ; //      LCDPort                            Port_2
 0000           ; //      
 0000           ; //---------------------------------------------------------------------------------
 0000           ; //   Hardware Connections
 0000           ; // Connect P0.1 to P0.2 and press reset.
 0000           ; // You should note the Value of Pulse Width on the LCD.
 0000           ; //
 0000           ; //---------------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // for timer 1 and motorcontrol 1
 0000           ; #define DATA_AVAILABLE 0x01//staat in de eerste bit van de flag 
 0000           ; #define FALLING_EDGE 0x02 // staat in de 2de bit van de flag 
 0000           ; WORD CapturePosEdge;
 0000           ; WORD CaptureNegEdge;
 0000           ; WORD PulseWidth;
 0000           ; BYTE Flags;
 0000           ; 
 0000           ; 
 0000           ; volatile BOOL done;//dit gedaan om compiler te verplichten waarde terug in te lezen (Caching tegen te gaan )
 0000           ; 
 0000           ; // for timer 2 and motor controll 2
 0000           ; #define DATA_AVAILABLE2 0x01 // new for motorcontroll2
 0000           ; #define FALLING_EDGE2 0x02    // new for motorcontroll2
 0000           ; WORD CapturePosEdge2;// new for motorcontroll2
 0000           ; WORD CaptureNegEdge2;// new for motorcontroll2
 0000           ; WORD PulseWidth2;// new for motorcontroll2
 0000           ; BYTE Flags2;
 0000           ; 
 0000           ; // for timer 3 and ultrasoon sensor 1
 0000           ; #define DATA_AVAILABLE3 0x01 
 0000           ; #define FALLING_EDGE3 0x02    
 0000           ; #define Set_Distance  50;
 0000           ; 
 0000           ; WORD CapturePosEdge3;
 0000           ; WORD CaptureNegEdge3;
 0000           ; WORD PulseWidth3;
 0000           ; BYTE Flags3;
 0000           ; 
 0000           ; void motorControll1(void);
 0000           ; void motorController(void);
 0000           ; void ultrasoonSensor(void);//long ultrasoon sensor(void);
 0000           ;  
 0000           ; #pragma interrupt_handler TimerCaptureISR// for motorcontroll2
 0000           ; #pragma interrupt_handler Timer2CaptureISR// new for motorcontroll2
 0000           ; #pragma interrupt_handler Timer3CaptureISR
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 114
 0000           ;    // Enable Global Interrupt   
 0000           ;    M8C_EnableGInt;
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 117
 0002           ;    
 0002           ;    // Clear the flags
 0002           ;    Flags = 0;
 0002 62D000            mov REG[0xd0],>_Flags
 0005 550000            mov [_Flags],0
 0008                   .dbline 118
 0008           ;    Flags2 = 0;// new for motorcontroll2
 0008 62D000            mov REG[0xd0],>_Flags2
 000B 550000            mov [_Flags2],0
 000E                   .dbline 119
 000E           ;    Flags3 = 0;
 000E 62D000            mov REG[0xd0],>_Flags3
 0011 550000            mov [_Flags3],0
 0014                   .dbline 121
 0014           ;    // Start timers and enable interrupt
 0014           ;    Timer_Start();
 0014 10                push X
 0015 7C0000            xcall _Timer_Start
 0018                   .dbline 122
 0018           ;    Timer_EnableInt();
 0018 7C0000            xcall _Timer_EnableInt
 001B                   .dbline 124
 001B           ;    
 001B           ;    Timer2_Start();// new for motorcontroll2
 001B 7C0000            xcall _Timer2_Start
 001E                   .dbline 125
 001E           ;    Timer2_EnableInt();// new for motorcontroll2
 001E 7C0000            xcall _Timer2_EnableInt
 0021                   .dbline 127
 0021           ;   
 0021           ;    Timer3_Start();
 0021 7C0000            xcall _Timer3_Start
 0024                   .dbline 128
 0024           ;    Timer3_EnableInt();
 0024 7C0000            xcall _Timer3_EnableInt
 0027                   .dbline 130
 0027           ;    
 0027           ;    PWM1_Start();      
 0027 7C0000            xcall _PWM1_Start
 002A                   .dbline 131
 002A           ;    PWM2_Start();
 002A 7C0000            xcall _PWM2_Start
 002D                   .dbline 132
 002D           ;    LCD_Start();
 002D 7C0000            xcall _LCD_Start
 0030                   .dbline 133
 0030           ;       LCD_Position(0,0);
 0030 5000              mov A,0
 0032 5700              mov X,0
 0034 7C0000            xcall _LCD_Position
 0037                   .dbline 134
 0037           ;          LCD_PrHexInt(0x55);
 0037 5700              mov X,0
 0039 5055              mov A,85
 003B 7C0000            xcall _LCD_PrHexInt
 003E 20                pop X
 003F                   .dbline 135
 003F           ;    PRT1DR = 0x80;
 003F 620480            mov REG[0x4],-128
 0042 8007              xjmp L3
 0044           L2:
 0044                   .dbline 138
 0044           ; 
 0044           ;    while(1)
 0044           ;    {
 0044                   .dbline 140
 0044           ;       //long OutputDistance = ultrasoonSensor(); 
 0044           ;       motorControll1();//OutputDistance
 0044 92DB              xcall _motorControll1
 0046                   .dbline 141
 0046           ;     motorControll2();//OutputDistance
 0046 92FD              xcall _motorControll2
 0048                   .dbline 142
 0048           ;       ultrasoonSensor();
 0048 931F              xcall _ultrasoonSensor
 004A                   .dbline 143
 004A           ;    }
 004A           L3:
 004A                   .dbline 137
 004A 8FF9              xjmp L2
 004C           X0:
 004C                   .dbline -2
 004C           L1:
 004C                   .dbline 0 ; func end
 004C 8FFF              jmp .
 004E                   .dbend
 004E                   .dbfunc e TimerCaptureISR _TimerCaptureISR fV
 004E           _TimerCaptureISR::
 004E                   .dbline -1
 004E 71C0              or F,-64
 0050 08                push A
 0051 5DD0              mov A,REG[0xd0]
 0053 08                push A
 0054 5DD3              mov A,REG[0xd3]
 0056 08                push A
 0057 5DD4              mov A,REG[0xd4]
 0059 08                push A
 005A 5DD5              mov A,REG[0xd5]
 005C 08                push A
 005D 62D000            mov REG[0xd0],>__r0
 0060 5100              mov A,[__r0]
 0062 08                push A
 0063 5100              mov A,[__r1]
 0065 08                push A
 0066 5100              mov A,[__r2]
 0068 08                push A
 0069 5100              mov A,[__r3]
 006B 08                push A
 006C 5100              mov A,[__r4]
 006E 08                push A
 006F 5100              mov A,[__r5]
 0071 08                push A
 0072 5100              mov A,[__r6]
 0074 08                push A
 0075 5100              mov A,[__r7]
 0077 08                push A
 0078 5100              mov A,[__r8]
 007A 08                push A
 007B 5100              mov A,[__r9]
 007D 08                push A
 007E 5100              mov A,[__r10]
 0080 08                push A
 0081 5100              mov A,[__r11]
 0083 08                push A
 0084 5100              mov A,[__rX]
 0086 08                push A
 0087 5100              mov A,[__rY]
 0089 08                push A
 008A 5100              mov A,[__rZ]
 008C 08                push A
 008D                   .dbline 147
 008D           ; }
 008D           ; 
 008D           ; void TimerCaptureISR(void)
 008D           ; {
 008D                   .dbline 148
 008D           ;    if(Flags & FALLING_EDGE)
 008D 62D000            mov REG[0xd0],>_Flags
 0090 470002            tst [_Flags],2
 0093 A049              jz L6
 0095                   .dbline 151
 0095           ;    {
 0095           ;       // Read the count on negative edge
 0095           ;       CaptureNegEdge = Timer_wReadCompareValue();
 0095                   .dbline 151
 0095 10                push X
 0096 7C0000            xcall _Timer_wReadCompareValue
 0099 62D000            mov REG[0xd0],>__r0
 009C 5A00              mov [__r0],X
 009E 20                pop X
 009F 08                push A
 00A0 5100              mov A,[__r0]
 00A2 62D000            mov REG[0xd0],>_CaptureNegEdge
 00A5 5300              mov [_CaptureNegEdge],A
 00A7 18                pop A
 00A8 5301              mov [_CaptureNegEdge+1],A
 00AA                   .dbline 154
 00AA           ; 
 00AA           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 00AA           ;       Timer_FUNC_LSB_REG &= ~0x80;
 00AA 7110              or F,0x10  ; iopage = 1
 00AC 41207F            and REG[0x20],127
 00AF                   .dbline 155
 00AF           ;       Flags &= ~FALLING_EDGE;
 00AF 70CF              and F,0xCF      ; iopage = 0
 00B1 62D000            mov REG[0xd0],>_Flags
 00B4 2600FD            and [_Flags],-3
 00B7                   .dbline 162
 00B7           ; 
 00B7           ;       // Calculate the pulswidth by finding difference between positive edge
 00B7           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 00B7           ;       // the result will be correct even if there is an underflow in the counter
 00B7           ;       // The result will be accurate as long as the total pulsewidth is less than
 00B7           ;       // 65535 timer ticks.
 00B7           ;       PulseWidth = CapturePosEdge - CaptureNegEdge;
 00B7 62D000            mov REG[0xd0],>_CapturePosEdge
 00BA 5101              mov A,[_CapturePosEdge+1]
 00BC 62D000            mov REG[0xd0],>_CaptureNegEdge
 00BF 1201              sub A,[_CaptureNegEdge+1]
 00C1 62D000            mov REG[0xd0],>_PulseWidth
 00C4 5301              mov [_PulseWidth+1],A
 00C6 62D000            mov REG[0xd0],>_CapturePosEdge
 00C9 5100              mov A,[_CapturePosEdge]
 00CB 62D000            mov REG[0xd0],>_CaptureNegEdge
 00CE 1A00              sbb A,[_CaptureNegEdge]
 00D0 62D000            mov REG[0xd0],>_PulseWidth
 00D3 5300              mov [_PulseWidth],A
 00D5                   .dbline 165
 00D5           ;       
 00D5           ;       // Set the Data available flag
 00D5           ;       Flags |= DATA_AVAILABLE;
 00D5 62D000            mov REG[0xd0],>_Flags
 00D8 2E0001            or [_Flags],1
 00DB                   .dbline 166
 00DB           ;    }
 00DB 8023              xjmp L7
 00DD           L6:
 00DD                   .dbline 168
 00DD           ;    else
 00DD           ;    {
 00DD                   .dbline 170
 00DD           ;       // Read the count on positive edge
 00DD           ;       CapturePosEdge = Timer_wReadCompareValue();
 00DD 10                push X
 00DE 7C0000            xcall _Timer_wReadCompareValue
 00E1 62D000            mov REG[0xd0],>__r0
 00E4 5A00              mov [__r0],X
 00E6 20                pop X
 00E7 08                push A
 00E8 5100              mov A,[__r0]
 00EA 62D000            mov REG[0xd0],>_CapturePosEdge
 00ED 5300              mov [_CapturePosEdge],A
 00EF 18                pop A
 00F0 5301              mov [_CapturePosEdge+1],A
 00F2                   .dbline 173
 00F2           ;       
 00F2           ;       // Change the capture to negative edge and set flag
 00F2           ;       Timer_FUNC_LSB_REG |= 0x80;
 00F2 7110              or F,0x10  ; iopage = 1
 00F4 432080            or REG[0x20],-128
 00F7                   .dbline 174
 00F7           ;       Flags |= FALLING_EDGE;
 00F7 70CF              and F,0xCF      ; iopage = 0
 00F9 62D000            mov REG[0xd0],>_Flags
 00FC 2E0002            or [_Flags],2
 00FF                   .dbline 175
 00FF           ;    }
 00FF           L7:
 00FF                   .dbline -2
 00FF           L5:
 00FF 62D000            mov REG[0xD0],>__r0
 0102 18                pop A
 0103 5300              mov [__rZ],A
 0105 18                pop A
 0106 5300              mov [__rY],A
 0108 18                pop A
 0109 5300              mov [__rX],A
 010B 18                pop A
 010C 5300              mov [__r11],A
 010E 18                pop A
 010F 5300              mov [__r10],A
 0111 18                pop A
 0112 5300              mov [__r9],A
 0114 18                pop A
 0115 5300              mov [__r8],A
 0117 18                pop A
 0118 5300              mov [__r7],A
 011A 18                pop A
 011B 5300              mov [__r6],A
 011D 18                pop A
 011E 5300              mov [__r5],A
 0120 18                pop A
 0121 5300              mov [__r4],A
 0123 18                pop A
 0124 5300              mov [__r3],A
 0126 18                pop A
 0127 5300              mov [__r2],A
 0129 18                pop A
 012A 5300              mov [__r1],A
 012C 18                pop A
 012D 5300              mov [__r0],A
 012F 18                pop A
 0130 60D5              mov REG[213],A
 0132 18                pop A
 0133 60D4              mov REG[212],A
 0135 18                pop A
 0136 60D3              mov REG[211],A
 0138 18                pop A
 0139 60D0              mov REG[208],A
 013B 18                pop A
 013C                   .dbline 0 ; func end
 013C 7E                reti
 013D                   .dbend
 013D                   .dbfunc e Timer2CaptureISR _Timer2CaptureISR fV
 013D           _Timer2CaptureISR::
 013D                   .dbline -1
 013D 71C0              or F,-64
 013F 08                push A
 0140 5DD0              mov A,REG[0xd0]
 0142 08                push A
 0143 5DD3              mov A,REG[0xd3]
 0145 08                push A
 0146 5DD4              mov A,REG[0xd4]
 0148 08                push A
 0149 5DD5              mov A,REG[0xd5]
 014B 08                push A
 014C 62D000            mov REG[0xd0],>__r0
 014F 5100              mov A,[__r0]
 0151 08                push A
 0152 5100              mov A,[__r1]
 0154 08                push A
 0155 5100              mov A,[__r2]
 0157 08                push A
 0158 5100              mov A,[__r3]
 015A 08                push A
 015B 5100              mov A,[__r4]
 015D 08                push A
 015E 5100              mov A,[__r5]
 0160 08                push A
 0161 5100              mov A,[__r6]
 0163 08                push A
 0164 5100              mov A,[__r7]
 0166 08                push A
 0167 5100              mov A,[__r8]
 0169 08                push A
 016A 5100              mov A,[__r9]
 016C 08                push A
 016D 5100              mov A,[__r10]
 016F 08                push A
 0170 5100              mov A,[__r11]
 0172 08                push A
 0173 5100              mov A,[__rX]
 0175 08                push A
 0176 5100              mov A,[__rY]
 0178 08                push A
 0179 5100              mov A,[__rZ]
 017B 08                push A
 017C                   .dbline 179
 017C           ; }
 017C           ; 
 017C           ; void Timer2CaptureISR(void)// new function for motorcontroll2
 017C           ; {
 017C                   .dbline 180
 017C           ;        if(Flags2 & FALLING_EDGE)//
 017C 62D000            mov REG[0xd0],>_Flags2
 017F 470002            tst [_Flags2],2
 0182 A049              jz L9
 0184                   .dbline 183
 0184           ;    {
 0184           ;       // Read the count on negative edge
 0184           ;       CaptureNegEdge2 = Timer2_wReadCompareValue();
 0184                   .dbline 183
 0184 10                push X
 0185 7C0000            xcall _Timer2_wReadCompareValue
 0188 62D000            mov REG[0xd0],>__r0
 018B 5A00              mov [__r0],X
 018D 20                pop X
 018E 08                push A
 018F 5100              mov A,[__r0]
 0191 62D000            mov REG[0xd0],>_CaptureNegEdge2
 0194 5300              mov [_CaptureNegEdge2],A
 0196 18                pop A
 0197 5301              mov [_CaptureNegEdge2+1],A
 0199                   .dbline 186
 0199           ; 
 0199           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 0199           ;       Timer2_FUNC_LSB_REG &= ~0x80;
 0199 7110              or F,0x10  ; iopage = 1
 019B 41287F            and REG[0x28],127
 019E                   .dbline 187
 019E           ;       Flags2 &= ~FALLING_EDGE2;// clearing faling edge bit in flags
 019E 70CF              and F,0xCF      ; iopage = 0
 01A0 62D000            mov REG[0xd0],>_Flags2
 01A3 2600FD            and [_Flags2],-3
 01A6                   .dbline 195
 01A6           ;       
 01A6           ; 
 01A6           ;       // Calculate the pulswidth by finding difference between positive edge
 01A6           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 01A6           ;       // the result will be correct even if there is an underflow in the counter
 01A6           ;       // The result will be accurate as long as the total pulsewidth is less than
 01A6           ;       // 65535 timer ticks.
 01A6           ;       PulseWidth2 = CapturePosEdge2 - CaptureNegEdge2;
 01A6 62D000            mov REG[0xd0],>_CapturePosEdge2
 01A9 5101              mov A,[_CapturePosEdge2+1]
 01AB 62D000            mov REG[0xd0],>_CaptureNegEdge2
 01AE 1201              sub A,[_CaptureNegEdge2+1]
 01B0 62D000            mov REG[0xd0],>_PulseWidth2
 01B3 5301              mov [_PulseWidth2+1],A
 01B5 62D000            mov REG[0xd0],>_CapturePosEdge2
 01B8 5100              mov A,[_CapturePosEdge2]
 01BA 62D000            mov REG[0xd0],>_CaptureNegEdge2
 01BD 1A00              sbb A,[_CaptureNegEdge2]
 01BF 62D000            mov REG[0xd0],>_PulseWidth2
 01C2 5300              mov [_PulseWidth2],A
 01C4                   .dbline 198
 01C4           ;       
 01C4           ;       // Set the Data available flag
 01C4           ;       Flags2 |= DATA_AVAILABLE2;
 01C4 62D000            mov REG[0xd0],>_Flags2
 01C7 2E0001            or [_Flags2],1
 01CA                   .dbline 199
 01CA           ;    }
 01CA 8023              xjmp L10
 01CC           L9:
 01CC                   .dbline 201
 01CC           ;    else
 01CC           ;    {
 01CC                   .dbline 203
 01CC           ;       // Read the count on positive edge
 01CC           ;       CapturePosEdge2 = Timer2_wReadCompareValue();
 01CC 10                push X
 01CD 7C0000            xcall _Timer2_wReadCompareValue
 01D0 62D000            mov REG[0xd0],>__r0
 01D3 5A00              mov [__r0],X
 01D5 20                pop X
 01D6 08                push A
 01D7 5100              mov A,[__r0]
 01D9 62D000            mov REG[0xd0],>_CapturePosEdge2
 01DC 5300              mov [_CapturePosEdge2],A
 01DE 18                pop A
 01DF 5301              mov [_CapturePosEdge2+1],A
 01E1                   .dbline 206
 01E1           ;       
 01E1           ;       // Change the capture to negative edge and set flag
 01E1           ;       Timer2_FUNC_LSB_REG |= 0x80;//0x80
 01E1 7110              or F,0x10  ; iopage = 1
 01E3 432880            or REG[0x28],-128
 01E6                   .dbline 207
 01E6           ;       Flags2 |= FALLING_EDGE2;
 01E6 70CF              and F,0xCF      ; iopage = 0
 01E8 62D000            mov REG[0xd0],>_Flags2
 01EB 2E0002            or [_Flags2],2
 01EE                   .dbline 208
 01EE           ;    }
 01EE           L10:
 01EE                   .dbline -2
 01EE           L8:
 01EE 62D000            mov REG[0xD0],>__r0
 01F1 18                pop A
 01F2 5300              mov [__rZ],A
 01F4 18                pop A
 01F5 5300              mov [__rY],A
 01F7 18                pop A
 01F8 5300              mov [__rX],A
 01FA 18                pop A
 01FB 5300              mov [__r11],A
 01FD 18                pop A
 01FE 5300              mov [__r10],A
 0200 18                pop A
 0201 5300              mov [__r9],A
 0203 18                pop A
 0204 5300              mov [__r8],A
 0206 18                pop A
 0207 5300              mov [__r7],A
 0209 18                pop A
 020A 5300              mov [__r6],A
 020C 18                pop A
 020D 5300              mov [__r5],A
 020F 18                pop A
 0210 5300              mov [__r4],A
 0212 18                pop A
 0213 5300              mov [__r3],A
 0215 18                pop A
 0216 5300              mov [__r2],A
 0218 18                pop A
 0219 5300              mov [__r1],A
 021B 18                pop A
 021C 5300              mov [__r0],A
 021E 18                pop A
 021F 60D5              mov REG[213],A
 0221 18                pop A
 0222 60D4              mov REG[212],A
 0224 18                pop A
 0225 60D3              mov REG[211],A
 0227 18                pop A
 0228 60D0              mov REG[208],A
 022A 18                pop A
 022B                   .dbline 0 ; func end
 022B 7E                reti
 022C                   .dbend
 022C                   .dbfunc e Timer3CaptureISR _Timer3CaptureISR fV
 022C           _Timer3CaptureISR::
 022C                   .dbline -1
 022C 71C0              or F,-64
 022E 08                push A
 022F 5DD0              mov A,REG[0xd0]
 0231 08                push A
 0232 5DD3              mov A,REG[0xd3]
 0234 08                push A
 0235 5DD4              mov A,REG[0xd4]
 0237 08                push A
 0238 5DD5              mov A,REG[0xd5]
 023A 08                push A
 023B 62D000            mov REG[0xd0],>__r0
 023E 5100              mov A,[__r0]
 0240 08                push A
 0241 5100              mov A,[__r1]
 0243 08                push A
 0244 5100              mov A,[__r2]
 0246 08                push A
 0247 5100              mov A,[__r3]
 0249 08                push A
 024A 5100              mov A,[__r4]
 024C 08                push A
 024D 5100              mov A,[__r5]
 024F 08                push A
 0250 5100              mov A,[__r6]
 0252 08                push A
 0253 5100              mov A,[__r7]
 0255 08                push A
 0256 5100              mov A,[__r8]
 0258 08                push A
 0259 5100              mov A,[__r9]
 025B 08                push A
 025C 5100              mov A,[__r10]
 025E 08                push A
 025F 5100              mov A,[__r11]
 0261 08                push A
 0262 5100              mov A,[__rX]
 0264 08                push A
 0265 5100              mov A,[__rY]
 0267 08                push A
 0268 5100              mov A,[__rZ]
 026A 08                push A
 026B                   .dbline 212
 026B           ; }
 026B           ; 
 026B           ; void Timer3CaptureISR(void)
 026B           ; {
 026B                   .dbline 213
 026B           ;    if(Flags3 & FALLING_EDGE3)
 026B 62D000            mov REG[0xd0],>_Flags3
 026E 470002            tst [_Flags3],2
 0271 A04F              jz L12
 0273                   .dbline 216
 0273           ;    {
 0273           ;       // Read the count on negative edge
 0273           ;       CaptureNegEdge3 = Timer3_wReadCompareValue();
 0273                   .dbline 216
 0273 10                push X
 0274 7C0000            xcall _Timer3_wReadCompareValue
 0277 62D000            mov REG[0xd0],>__r0
 027A 5A00              mov [__r0],X
 027C 20                pop X
 027D 08                push A
 027E 5100              mov A,[__r0]
 0280 62D000            mov REG[0xd0],>_CaptureNegEdge3
 0283 5300              mov [_CaptureNegEdge3],A
 0285 18                pop A
 0286 5301              mov [_CaptureNegEdge3+1],A
 0288                   .dbline 219
 0288           ; 
 0288           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 0288           ;       Timer3_FUNC_LSB_REG &= ~0x80;
 0288 7110              or F,0x10  ; iopage = 1
 028A 41307F            and REG[0x30],127
 028D                   .dbline 220
 028D           ;       Flags3 &= ~FALLING_EDGE3;
 028D 70CF              and F,0xCF      ; iopage = 0
 028F 62D000            mov REG[0xd0],>_Flags3
 0292 2600FD            and [_Flags3],-3
 0295                   .dbline 227
 0295           ; 
 0295           ;       // Calculate the pulswidth by finding difference between positive edge
 0295           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 0295           ;       // the result will be correct even if there is an underflow in the counter
 0295           ;       // The result will be accurate as long as the total pulsewidth is less than
 0295           ;       // 65535 timer ticks.
 0295           ;       PulseWidth3 = CapturePosEdge3 - CaptureNegEdge3;
 0295 62D000            mov REG[0xd0],>_CapturePosEdge3
 0298 5101              mov A,[_CapturePosEdge3+1]
 029A 62D000            mov REG[0xd0],>_CaptureNegEdge3
 029D 1201              sub A,[_CaptureNegEdge3+1]
 029F 62D000            mov REG[0xd0],>_PulseWidth3
 02A2 5301              mov [_PulseWidth3+1],A
 02A4 62D000            mov REG[0xd0],>_CapturePosEdge3
 02A7 5100              mov A,[_CapturePosEdge3]
 02A9 62D000            mov REG[0xd0],>_CaptureNegEdge3
 02AC 1A00              sbb A,[_CaptureNegEdge3]
 02AE 62D000            mov REG[0xd0],>_PulseWidth3
 02B1 5300              mov [_PulseWidth3],A
 02B3                   .dbline 230
 02B3           ;       
 02B3           ;       // Set the Data available flag
 02B3           ;       Flags3 |= DATA_AVAILABLE3;
 02B3 62D000            mov REG[0xd0],>_Flags3
 02B6 2E0001            or [_Flags3],1
 02B9                   .dbline 231
 02B9           ;         done = TRUE ;// 
 02B9 62D000            mov REG[0xd0],>_done
 02BC 550001            mov [_done],1
 02BF                   .dbline 232
 02BF           ;    }
 02BF 8023              xjmp L13
 02C1           L12:
 02C1                   .dbline 234
 02C1           ;    else
 02C1           ;    {
 02C1                   .dbline 236
 02C1           ;       // Read the count on positive edge
 02C1           ;       CapturePosEdge3 = Timer3_wReadCompareValue();
 02C1 10                push X
 02C2 7C0000            xcall _Timer3_wReadCompareValue
 02C5 62D000            mov REG[0xd0],>__r0
 02C8 5A00              mov [__r0],X
 02CA 20                pop X
 02CB 08                push A
 02CC 5100              mov A,[__r0]
 02CE 62D000            mov REG[0xd0],>_CapturePosEdge3
 02D1 5300              mov [_CapturePosEdge3],A
 02D3 18                pop A
 02D4 5301              mov [_CapturePosEdge3+1],A
 02D6                   .dbline 239
 02D6           ;       
 02D6           ;       // Change the capture to negative edge and set flag
 02D6           ;       Timer3_FUNC_LSB_REG |= 0x80;
 02D6 7110              or F,0x10  ; iopage = 1
 02D8 433080            or REG[0x30],-128
 02DB                   .dbline 240
 02DB           ;       Flags3 |= FALLING_EDGE3;
 02DB 70CF              and F,0xCF      ; iopage = 0
 02DD 62D000            mov REG[0xd0],>_Flags3
 02E0 2E0002            or [_Flags3],2
 02E3                   .dbline 241
 02E3           ;    }
 02E3           L13:
 02E3                   .dbline -2
 02E3           L11:
 02E3 62D000            mov REG[0xD0],>__r0
 02E6 18                pop A
 02E7 5300              mov [__rZ],A
 02E9 18                pop A
 02EA 5300              mov [__rY],A
 02EC 18                pop A
 02ED 5300              mov [__rX],A
 02EF 18                pop A
 02F0 5300              mov [__r11],A
 02F2 18                pop A
 02F3 5300              mov [__r10],A
 02F5 18                pop A
 02F6 5300              mov [__r9],A
 02F8 18                pop A
 02F9 5300              mov [__r8],A
 02FB 18                pop A
 02FC 5300              mov [__r7],A
 02FE 18                pop A
 02FF 5300              mov [__r6],A
 0301 18                pop A
 0302 5300              mov [__r5],A
 0304 18                pop A
 0305 5300              mov [__r4],A
 0307 18                pop A
 0308 5300              mov [__r3],A
 030A 18                pop A
 030B 5300              mov [__r2],A
 030D 18                pop A
 030E 5300              mov [__r1],A
 0310 18                pop A
 0311 5300              mov [__r0],A
 0313 18                pop A
 0314 60D5              mov REG[213],A
 0316 18                pop A
 0317 60D4              mov REG[212],A
 0319 18                pop A
 031A 60D3              mov REG[211],A
 031C 18                pop A
 031D 60D0              mov REG[208],A
 031F 18                pop A
 0320                   .dbline 0 ; func end
 0320 7E                reti
 0321                   .dbend
 0321                   .dbfunc e motorControll1 _motorControll1 fV
 0321           _motorControll1::
 0321                   .dbline -1
 0321                   .dbline 245
 0321           ; }
 0321           ; 
 0321           ; void motorControll1(void)//long OutputDistance
 0321           ; {
 0321                   .dbline 248
 0321           ;                       
 0321           ;          // Check if pulsewidth data is available
 0321           ;     if(Flags & DATA_AVAILABLE)
 0321 62D000            mov REG[0xd0],>_Flags
 0324 470001            tst [_Flags],1
 0327 A01C              jz L15
 0329                   .dbline 250
 0329           ;    {
 0329           ;          LCD_Position(0,0);
 0329                   .dbline 250
 0329 10                push X
 032A 5000              mov A,0
 032C 5700              mov X,0
 032E 7C0000            xcall _LCD_Position
 0331                   .dbline 251
 0331           ;          LCD_PrHexInt(PulseWidth);
 0331 62D000            mov REG[0xd0],>_PulseWidth
 0334 5100              mov A,[_PulseWidth]
 0336 08                push A
 0337 5101              mov A,[_PulseWidth+1]
 0339 20                pop X
 033A 7C0000            xcall _LCD_PrHexInt
 033D 20                pop X
 033E                   .dbline 252
 033E           ;                Flags &= ~DATA_AVAILABLE;
 033E 62D000            mov REG[0xd0],>_Flags
 0341 2600FE            and [_Flags],-2
 0344                   .dbline 255
 0344           ;                       
 0344           ;                       
 0344           ;       }
 0344           L15:
 0344                   .dbline -2
 0344           L14:
 0344                   .dbline 0 ; func end
 0344 7F                ret
 0345                   .dbend
 0345                   .dbfunc e motorControll2 _motorControll2 fV
 0345           _motorControll2::
 0345                   .dbline -1
 0345                   .dbline 262
 0345           ;    
 0345           ;        
 0345           ;       
 0345           ; }
 0345           ; 
 0345           ; void motorControll2(void)// long OutputDistance
 0345           ; {
 0345                   .dbline 263
 0345           ;       if(Flags2 & DATA_AVAILABLE2)
 0345 62D000            mov REG[0xd0],>_Flags2
 0348 470001            tst [_Flags2],1
 034B A01C              jz L18
 034D                   .dbline 265
 034D           ;       {
 034D           ;                LCD_Position(5,0);
 034D                   .dbline 265
 034D 10                push X
 034E 5700              mov X,0
 0350 5005              mov A,5
 0352 7C0000            xcall _LCD_Position
 0355                   .dbline 266
 0355           ;          LCD_PrHexInt(PulseWidth2);
 0355 62D000            mov REG[0xd0],>_PulseWidth2
 0358 5100              mov A,[_PulseWidth2]
 035A 08                push A
 035B 5101              mov A,[_PulseWidth2+1]
 035D 20                pop X
 035E 7C0000            xcall _LCD_PrHexInt
 0361 20                pop X
 0362                   .dbline 268
 0362           ;        
 0362           ;          Flags2 &= ~DATA_AVAILABLE2;
 0362 62D000            mov REG[0xd0],>_Flags2
 0365 2600FE            and [_Flags2],-2
 0368                   .dbline 269
 0368           ;       }
 0368           L18:
 0368                   .dbline -2
 0368           L17:
 0368                   .dbline 0 ; func end
 0368 7F                ret
 0369                   .dbend
 0369                   .dbfunc e ultrasoonSensor _ultrasoonSensor fV
 0369           ;       distance -> X+0
 0369           _ultrasoonSensor::
 0369                   .dbline -1
 0369 10                push X
 036A 4F                mov X,SP
 036B 3804              add SP,4
 036D                   .dbline 276
 036D           ;        
 036D           ;       
 036D           ; }
 036D           ; 
 036D           ; 
 036D           ; void ultrasoonSensor(void)
 036D           ; {
 036D                   .dbline 280
 036D           ;       long distance;
 036D           ;       //this if statmend ensure's the trig pin is trigerd when needed
 036D           ;       
 036D           ;    if(done == FALSE)
 036D 62D000            mov REG[0xd0],>_done
 0370 3C0000            cmp [_done],0
 0373 B019              jnz L21
 0375                   .dbline 282
 0375           ;       {
 0375           ;               PRT1DR |= 0x01;
 0375                   .dbline 282
 0375 430401            or REG[0x4],1
 0378                   .dbline 283
 0378           ;           asm("nop");
 0378 40                        nop
 0379           
 0379                   .dbline 284
 0379           ;               asm("nop");
 0379 40                        nop
 037A           
 037A                   .dbline 285
 037A           ;               asm("nop");
 037A 40                        nop
 037B           
 037B                   .dbline 286
 037B           ;               asm("nop");
 037B 40                        nop
 037C           
 037C                   .dbline 287
 037C           ;               asm("nop");
 037C 40                        nop
 037D           
 037D                   .dbline 288
 037D           ;               asm("nop");
 037D 40                        nop
 037E           
 037E                   .dbline 289
 037E           ;               asm("nop");
 037E 40                        nop
 037F           
 037F                   .dbline 290
 037F           ;               asm("nop");
 037F 40                        nop
 0380           
 0380                   .dbline 291
 0380           ;               asm("nop");
 0380 40                        nop
 0381           
 0381                   .dbline 292
 0381           ;               asm("nop");
 0381 40                        nop
 0382           
 0382                   .dbline 293
 0382           ;               asm("nop");
 0382 40                        nop
 0383           
 0383                   .dbline 294
 0383           ;               asm("nop");
 0383 40                        nop
 0384           
 0384                   .dbline 295
 0384           ;               asm("nop");
 0384 40                        nop
 0385           
 0385                   .dbline 296
 0385           ;               asm("nop");
 0385 40                        nop
 0386           
 0386                   .dbline 297
 0386           ;               asm("nop");
 0386 40                        nop
 0387           
 0387                   .dbline 298
 0387           ;               asm("nop");
 0387 40                        nop
 0388           
 0388                   .dbline 299
 0388           ;               asm("nop");
 0388 40                        nop
 0389           
 0389                   .dbline 300
 0389           ;               asm("nop");
 0389 40                        nop
 038A           
 038A                   .dbline 301
 038A           ;               PRT1DR &= ~0x01;// pin P1[0]
 038A 4104FE            and REG[0x4],-2
 038D                   .dbline 303
 038D           ; 
 038D           ;       }
 038D           L21:
 038D                   .dbline 304
 038D           ;       if(Flags3 & DATA_AVAILABLE3)// do if databit is set 
 038D 62D000            mov REG[0xd0],>_Flags3
 0390 470001            tst [_Flags3],1
 0393 A022              jz L23
 0395                   .dbline 307
 0395           ;     {
 0395           ;       
 0395           ;                LCD_Position(5,5);
 0395                   .dbline 307
 0395 10                push X
 0396 5005              mov A,5
 0398 5705              mov X,5
 039A 7C0000            xcall _LCD_Position
 039D                   .dbline 308
 039D           ;          LCD_PrHexInt(PulseWidth3);
 039D 62D000            mov REG[0xd0],>_PulseWidth3
 03A0 5100              mov A,[_PulseWidth3]
 03A2 08                push A
 03A3 5101              mov A,[_PulseWidth3+1]
 03A5 20                pop X
 03A6 7C0000            xcall _LCD_PrHexInt
 03A9 20                pop X
 03AA                   .dbline 310
 03AA           ;        
 03AA           ;          Flags3 &= ~DATA_AVAILABLE3;
 03AA 62D000            mov REG[0xd0],>_Flags3
 03AD 2600FE            and [_Flags3],-2
 03B0                   .dbline 311
 03B0           ;               done = FALSE;
 03B0 62D000            mov REG[0xd0],>_done
 03B3 550000            mov [_done],0
 03B6                   .dbline 312
 03B6           ;     }  
 03B6           L23:
 03B6                   .dbline -2
 03B6           L20:
 03B6 38FC              add SP,-4
 03B8 20                pop X
 03B9                   .dbline 0 ; func end
 03B9 7F                ret
 03BA                   .dbsym l distance 0 L
 03BA                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags3::
 0000 00                .byte 0
 0001                   .dbsym e Flags3 _Flags3 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth3::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth3 _PulseWidth3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge3::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge3 _CaptureNegEdge3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge3::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge3 _CapturePosEdge3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags2::
 0000 00                .byte 0
 0001                   .dbsym e Flags2 _Flags2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth2::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth2 _PulseWidth2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge2::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge2 _CaptureNegEdge2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge2::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge2 _CapturePosEdge2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _done::
 0000 00                .byte 0
 0001                   .dbsym e done _done c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags::
 0000 00                .byte 0
 0001                   .dbsym e Flags _Flags c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth _PulseWidth i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge _CaptureNegEdge i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge _CapturePosEdge i
