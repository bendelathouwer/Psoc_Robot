 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 112
 0000           ; //****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; //  FILENAME: main.c
 0000           ; //   Made for project 2 in the second semester of school
 0000           ; //
 0000           ; //  DESCRIPTION: Main file of the Psoc_robot project.
 0000           ; //
 0000           ; //-----------------------------------------------------------------------------
 0000           ; // 
 0000           ; //*****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; ////***************************************************************************************
 0000           ; 
 0000           ; //------------------------------------------------------------------------------
 0000           ; // Name: Psoc_robot
 0000           ; //------------------------------------------------------------------------------
 0000           ; //------------------------------------------------------------------------------
 0000           ; // For Device: CY8C29466
 0000           ; //------------------------------------------------------------------------------
 0000           ; // Required Software:  PSoC Designer 5.3
 0000           ; 
 0000           ; // Project Settings: 
 0000           ; //      
 0000           ; //      Power Setting [Vcc/SysClk Freq]:  5.0V/24MHz
 0000           ; //      CPU Clock:                        Sysclk/1  
 0000           ; //      VC1                               Sysclk/12
 0000           ; //      VC2                               VC1/2 = Sysclk/24
 0000           ; //      
 0000           ; //            Timer:                          `                         For reading one joystick channel      
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareType                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_0
 0000           ; 
 0000           ; //    Timer2:                         `                         For reading one joystick channel      
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareType                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_1
 0000           ; //    
 0000           ; //      Timer3:                               `                         For reading the  ultrasonic sensor
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareTy pe                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_3
 0000           ; //            
 0000           ; //            
 0000           ; //    Pwm conected to port                 Port_0_4
 0000           ; //    PWM:                                                               For controlling one motor on one side
 0000           ; //      Clock                              VC2
 0000           ; //      Enable                             High
 0000           ; //      Period                             1000
 0000           ; //      PulseWidth                         0
 0000           ; //      CompareType                        Less than 
 0000           ; //      Interrupt Type                     Terminal count
 0000           ; //      LCD:
 0000           ; //      LCDPort                            Port_2
 0000           ; //      
 0000           ; //---------------------------------------------------------------------------------
 0000           ; //   Hardware Connections
 0000           ; // Connect P0.1 to P0.2 and press reset.
 0000           ; // You should note the Value of Pulse Width on the LCD.
 0000           ; //
 0000           ; //---------------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // for timer 1 and motorcontrol 1
 0000           ; #define DATA_AVAILABLE 0x01//staat in de eerste bit van de flag 
 0000           ; #define FALLING_EDGE 0x02 // staat in de 2de bit van de flag 
 0000           ; WORD CapturePosEdge;
 0000           ; WORD CaptureNegEdge;
 0000           ; WORD PulseWidth;
 0000           ; BYTE Flags;
 0000           ; 
 0000           ; 
 0000           ; volatile BOOL done;//dit gedaan om compiler te verplichten waarde terug in te lezen (Caching tegen te gaan )
 0000           ; 
 0000           ; // for timer 2 and motor controll 2
 0000           ; #define DATA_AVAILABLE2 0x01 // new for motorcontroll2
 0000           ; #define FALLING_EDGE2 0x02    // new for motorcontroll2
 0000           ; WORD CapturePosEdge2;// new for motorcontroll2
 0000           ; WORD CaptureNegEdge2;// new for motorcontroll2
 0000           ; WORD PulseWidth2;// new for motorcontroll2
 0000           ; BYTE Flags2;
 0000           ; 
 0000           ; // for timer 3 and ultrasoon sensor 1
 0000           ; #define DATA_AVAILABLE3 0x01 
 0000           ; #define FALLING_EDGE3 0x02    
 0000           ; #define Set_Distance  50;
 0000           ; 
 0000           ; WORD CapturePosEdge3;
 0000           ; WORD CaptureNegEdge3;
 0000           ; WORD PulseWidth3;
 0000           ; BYTE Flags3;
 0000           ; 
 0000           ; void motorControll1(void);
 0000           ; void motorController(void);
 0000           ; void ultrasoonSensor(void);//long ultrasoon sensor(void);
 0000           ;  
 0000           ; #pragma interrupt_handler TimerCaptureISR// for motorcontroll2
 0000           ; #pragma interrupt_handler Timer2CaptureISR// new for motorcontroll2
 0000           ; #pragma interrupt_handler Timer3CaptureISR
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 114
 0000           ;    // Enable Global Interrupt   
 0000           ;    M8C_EnableGInt;
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 117
 0002           ;    
 0002           ;    // Clear the flags
 0002           ;    Flags = 0;
 0002 62D000            mov REG[0xd0],>_Flags
 0005 550000            mov [_Flags],0
 0008                   .dbline 118
 0008           ;    Flags2 = 0;// new for motorcontroll2
 0008 62D000            mov REG[0xd0],>_Flags2
 000B 550000            mov [_Flags2],0
 000E                   .dbline 119
 000E           ;    Flags3 = 0;
 000E 62D000            mov REG[0xd0],>_Flags3
 0011 550000            mov [_Flags3],0
 0014                   .dbline 121
 0014           ;    // Start timers and enable interrupt
 0014           ;    Timer_Start();
 0014 10                push X
 0015 7C0000            xcall _Timer_Start
 0018                   .dbline 122
 0018           ;    Timer_EnableInt();
 0018 7C0000            xcall _Timer_EnableInt
 001B                   .dbline 124
 001B           ;    
 001B           ;    Timer2_Start();// new for motorcontroll2
 001B 7C0000            xcall _Timer2_Start
 001E                   .dbline 125
 001E           ;    Timer2_EnableInt();// new for motorcontroll2
 001E 7C0000            xcall _Timer2_EnableInt
 0021                   .dbline 127
 0021           ;   
 0021           ;    Timer3_Start();
 0021 7C0000            xcall _Timer3_Start
 0024                   .dbline 128
 0024           ;    Timer3_EnableInt();
 0024 7C0000            xcall _Timer3_EnableInt
 0027                   .dbline 130
 0027           ;    
 0027           ;    PWM1_Start();      
 0027 7C0000            xcall _PWM1_Start
 002A                   .dbline 131
 002A           ;    PWM2_Start();
 002A 7C0000            xcall _PWM2_Start
 002D                   .dbline 132
 002D           ;    LCD_Start();
 002D 7C0000            xcall _LCD_Start
 0030 20                pop X
 0031                   .dbline 134
 0031           ;    
 0031           ;       PRT1DR = 0x80;
 0031 620480            mov REG[0x4],-128
 0034 8007              xjmp L3
 0036           L2:
 0036                   .dbline 137
 0036           ; 
 0036           ;    while(1)
 0036           ;    {
 0036                   .dbline 139
 0036           ;       //long OutputDistance = ultrasoonSensor(); 
 0036           ;       motorControll1();//OutputDistance
 0036 92DB              xcall _motorControll1
 0038                   .dbline 140
 0038           ;     motorControll2();//OutputDistance
 0038 92FD              xcall _motorControll2
 003A                   .dbline 141
 003A           ;       ultrasoonSensor();
 003A 931F              xcall _ultrasoonSensor
 003C                   .dbline 142
 003C           ;    }
 003C           L3:
 003C                   .dbline 136
 003C 8FF9              xjmp L2
 003E           X0:
 003E                   .dbline -2
 003E           L1:
 003E                   .dbline 0 ; func end
 003E 8FFF              jmp .
 0040                   .dbend
 0040                   .dbfunc e TimerCaptureISR _TimerCaptureISR fV
 0040           _TimerCaptureISR::
 0040                   .dbline -1
 0040 71C0              or F,-64
 0042 08                push A
 0043 5DD0              mov A,REG[0xd0]
 0045 08                push A
 0046 5DD3              mov A,REG[0xd3]
 0048 08                push A
 0049 5DD4              mov A,REG[0xd4]
 004B 08                push A
 004C 5DD5              mov A,REG[0xd5]
 004E 08                push A
 004F 62D000            mov REG[0xd0],>__r0
 0052 5100              mov A,[__r0]
 0054 08                push A
 0055 5100              mov A,[__r1]
 0057 08                push A
 0058 5100              mov A,[__r2]
 005A 08                push A
 005B 5100              mov A,[__r3]
 005D 08                push A
 005E 5100              mov A,[__r4]
 0060 08                push A
 0061 5100              mov A,[__r5]
 0063 08                push A
 0064 5100              mov A,[__r6]
 0066 08                push A
 0067 5100              mov A,[__r7]
 0069 08                push A
 006A 5100              mov A,[__r8]
 006C 08                push A
 006D 5100              mov A,[__r9]
 006F 08                push A
 0070 5100              mov A,[__r10]
 0072 08                push A
 0073 5100              mov A,[__r11]
 0075 08                push A
 0076 5100              mov A,[__rX]
 0078 08                push A
 0079 5100              mov A,[__rY]
 007B 08                push A
 007C 5100              mov A,[__rZ]
 007E 08                push A
 007F                   .dbline 146
 007F           ; }
 007F           ; 
 007F           ; void TimerCaptureISR(void)
 007F           ; {
 007F                   .dbline 147
 007F           ;    if(Flags & FALLING_EDGE)
 007F 62D000            mov REG[0xd0],>_Flags
 0082 470002            tst [_Flags],2
 0085 A049              jz L6
 0087                   .dbline 150
 0087           ;    {
 0087           ;       // Read the count on negative edge
 0087           ;       CaptureNegEdge = Timer_wReadCompareValue();
 0087                   .dbline 150
 0087 10                push X
 0088 7C0000            xcall _Timer_wReadCompareValue
 008B 62D000            mov REG[0xd0],>__r0
 008E 5A00              mov [__r0],X
 0090 20                pop X
 0091 08                push A
 0092 5100              mov A,[__r0]
 0094 62D000            mov REG[0xd0],>_CaptureNegEdge
 0097 5300              mov [_CaptureNegEdge],A
 0099 18                pop A
 009A 5301              mov [_CaptureNegEdge+1],A
 009C                   .dbline 153
 009C           ; 
 009C           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 009C           ;       Timer_FUNC_LSB_REG &= ~0x80;
 009C 7110              or F,0x10  ; iopage = 1
 009E 41207F            and REG[0x20],127
 00A1                   .dbline 154
 00A1           ;       Flags &= ~FALLING_EDGE;
 00A1 70CF              and F,0xCF      ; iopage = 0
 00A3 62D000            mov REG[0xd0],>_Flags
 00A6 2600FD            and [_Flags],-3
 00A9                   .dbline 161
 00A9           ; 
 00A9           ;       // Calculate the pulswidth by finding difference between positive edge
 00A9           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 00A9           ;       // the result will be correct even if there is an underflow in the counter
 00A9           ;       // The result will be accurate as long as the total pulsewidth is less than
 00A9           ;       // 65535 timer ticks.
 00A9           ;       PulseWidth = CapturePosEdge - CaptureNegEdge;
 00A9 62D000            mov REG[0xd0],>_CapturePosEdge
 00AC 5101              mov A,[_CapturePosEdge+1]
 00AE 62D000            mov REG[0xd0],>_CaptureNegEdge
 00B1 1201              sub A,[_CaptureNegEdge+1]
 00B3 62D000            mov REG[0xd0],>_PulseWidth
 00B6 5301              mov [_PulseWidth+1],A
 00B8 62D000            mov REG[0xd0],>_CapturePosEdge
 00BB 5100              mov A,[_CapturePosEdge]
 00BD 62D000            mov REG[0xd0],>_CaptureNegEdge
 00C0 1A00              sbb A,[_CaptureNegEdge]
 00C2 62D000            mov REG[0xd0],>_PulseWidth
 00C5 5300              mov [_PulseWidth],A
 00C7                   .dbline 164
 00C7           ;       
 00C7           ;       // Set the Data available flag
 00C7           ;       Flags |= DATA_AVAILABLE;
 00C7 62D000            mov REG[0xd0],>_Flags
 00CA 2E0001            or [_Flags],1
 00CD                   .dbline 165
 00CD           ;    }
 00CD 8023              xjmp L7
 00CF           L6:
 00CF                   .dbline 167
 00CF           ;    else
 00CF           ;    {
 00CF                   .dbline 169
 00CF           ;       // Read the count on positive edge
 00CF           ;       CapturePosEdge = Timer_wReadCompareValue();
 00CF 10                push X
 00D0 7C0000            xcall _Timer_wReadCompareValue
 00D3 62D000            mov REG[0xd0],>__r0
 00D6 5A00              mov [__r0],X
 00D8 20                pop X
 00D9 08                push A
 00DA 5100              mov A,[__r0]
 00DC 62D000            mov REG[0xd0],>_CapturePosEdge
 00DF 5300              mov [_CapturePosEdge],A
 00E1 18                pop A
 00E2 5301              mov [_CapturePosEdge+1],A
 00E4                   .dbline 172
 00E4           ;       
 00E4           ;       // Change the capture to negative edge and set flag
 00E4           ;       Timer_FUNC_LSB_REG |= 0x80;
 00E4 7110              or F,0x10  ; iopage = 1
 00E6 432080            or REG[0x20],-128
 00E9                   .dbline 173
 00E9           ;       Flags |= FALLING_EDGE;
 00E9 70CF              and F,0xCF      ; iopage = 0
 00EB 62D000            mov REG[0xd0],>_Flags
 00EE 2E0002            or [_Flags],2
 00F1                   .dbline 174
 00F1           ;    }
 00F1           L7:
 00F1                   .dbline -2
 00F1           L5:
 00F1 62D000            mov REG[0xD0],>__r0
 00F4 18                pop A
 00F5 5300              mov [__rZ],A
 00F7 18                pop A
 00F8 5300              mov [__rY],A
 00FA 18                pop A
 00FB 5300              mov [__rX],A
 00FD 18                pop A
 00FE 5300              mov [__r11],A
 0100 18                pop A
 0101 5300              mov [__r10],A
 0103 18                pop A
 0104 5300              mov [__r9],A
 0106 18                pop A
 0107 5300              mov [__r8],A
 0109 18                pop A
 010A 5300              mov [__r7],A
 010C 18                pop A
 010D 5300              mov [__r6],A
 010F 18                pop A
 0110 5300              mov [__r5],A
 0112 18                pop A
 0113 5300              mov [__r4],A
 0115 18                pop A
 0116 5300              mov [__r3],A
 0118 18                pop A
 0119 5300              mov [__r2],A
 011B 18                pop A
 011C 5300              mov [__r1],A
 011E 18                pop A
 011F 5300              mov [__r0],A
 0121 18                pop A
 0122 60D5              mov REG[213],A
 0124 18                pop A
 0125 60D4              mov REG[212],A
 0127 18                pop A
 0128 60D3              mov REG[211],A
 012A 18                pop A
 012B 60D0              mov REG[208],A
 012D 18                pop A
 012E                   .dbline 0 ; func end
 012E 7E                reti
 012F                   .dbend
 012F                   .dbfunc e Timer2CaptureISR _Timer2CaptureISR fV
 012F           _Timer2CaptureISR::
 012F                   .dbline -1
 012F 71C0              or F,-64
 0131 08                push A
 0132 5DD0              mov A,REG[0xd0]
 0134 08                push A
 0135 5DD3              mov A,REG[0xd3]
 0137 08                push A
 0138 5DD4              mov A,REG[0xd4]
 013A 08                push A
 013B 5DD5              mov A,REG[0xd5]
 013D 08                push A
 013E 62D000            mov REG[0xd0],>__r0
 0141 5100              mov A,[__r0]
 0143 08                push A
 0144 5100              mov A,[__r1]
 0146 08                push A
 0147 5100              mov A,[__r2]
 0149 08                push A
 014A 5100              mov A,[__r3]
 014C 08                push A
 014D 5100              mov A,[__r4]
 014F 08                push A
 0150 5100              mov A,[__r5]
 0152 08                push A
 0153 5100              mov A,[__r6]
 0155 08                push A
 0156 5100              mov A,[__r7]
 0158 08                push A
 0159 5100              mov A,[__r8]
 015B 08                push A
 015C 5100              mov A,[__r9]
 015E 08                push A
 015F 5100              mov A,[__r10]
 0161 08                push A
 0162 5100              mov A,[__r11]
 0164 08                push A
 0165 5100              mov A,[__rX]
 0167 08                push A
 0168 5100              mov A,[__rY]
 016A 08                push A
 016B 5100              mov A,[__rZ]
 016D 08                push A
 016E                   .dbline 178
 016E           ; }
 016E           ; 
 016E           ; void Timer2CaptureISR(void)// new function for motorcontroll2
 016E           ; {
 016E                   .dbline 179
 016E           ;        if(Flags2 & FALLING_EDGE)//
 016E 62D000            mov REG[0xd0],>_Flags2
 0171 470002            tst [_Flags2],2
 0174 A049              jz L9
 0176                   .dbline 182
 0176           ;    {
 0176           ;       // Read the count on negative edge
 0176           ;       CaptureNegEdge2 = Timer2_wReadCompareValue();
 0176                   .dbline 182
 0176 10                push X
 0177 7C0000            xcall _Timer2_wReadCompareValue
 017A 62D000            mov REG[0xd0],>__r0
 017D 5A00              mov [__r0],X
 017F 20                pop X
 0180 08                push A
 0181 5100              mov A,[__r0]
 0183 62D000            mov REG[0xd0],>_CaptureNegEdge2
 0186 5300              mov [_CaptureNegEdge2],A
 0188 18                pop A
 0189 5301              mov [_CaptureNegEdge2+1],A
 018B                   .dbline 185
 018B           ; 
 018B           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 018B           ;       Timer2_FUNC_LSB_REG &= ~0x80;
 018B 7110              or F,0x10  ; iopage = 1
 018D 41287F            and REG[0x28],127
 0190                   .dbline 186
 0190           ;       Flags2 &= ~FALLING_EDGE2;// clearing faling edge bit in flags
 0190 70CF              and F,0xCF      ; iopage = 0
 0192 62D000            mov REG[0xd0],>_Flags2
 0195 2600FD            and [_Flags2],-3
 0198                   .dbline 194
 0198           ;       
 0198           ; 
 0198           ;       // Calculate the pulswidth by finding difference between positive edge
 0198           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 0198           ;       // the result will be correct even if there is an underflow in the counter
 0198           ;       // The result will be accurate as long as the total pulsewidth is less than
 0198           ;       // 65535 timer ticks.
 0198           ;       PulseWidth2 = CapturePosEdge2 - CaptureNegEdge2;
 0198 62D000            mov REG[0xd0],>_CapturePosEdge2
 019B 5101              mov A,[_CapturePosEdge2+1]
 019D 62D000            mov REG[0xd0],>_CaptureNegEdge2
 01A0 1201              sub A,[_CaptureNegEdge2+1]
 01A2 62D000            mov REG[0xd0],>_PulseWidth2
 01A5 5301              mov [_PulseWidth2+1],A
 01A7 62D000            mov REG[0xd0],>_CapturePosEdge2
 01AA 5100              mov A,[_CapturePosEdge2]
 01AC 62D000            mov REG[0xd0],>_CaptureNegEdge2
 01AF 1A00              sbb A,[_CaptureNegEdge2]
 01B1 62D000            mov REG[0xd0],>_PulseWidth2
 01B4 5300              mov [_PulseWidth2],A
 01B6                   .dbline 197
 01B6           ;       
 01B6           ;       // Set the Data available flag
 01B6           ;       Flags2 |= DATA_AVAILABLE2;
 01B6 62D000            mov REG[0xd0],>_Flags2
 01B9 2E0001            or [_Flags2],1
 01BC                   .dbline 198
 01BC           ;    }
 01BC 8023              xjmp L10
 01BE           L9:
 01BE                   .dbline 200
 01BE           ;    else
 01BE           ;    {
 01BE                   .dbline 202
 01BE           ;       // Read the count on positive edge
 01BE           ;       CapturePosEdge2 = Timer2_wReadCompareValue();
 01BE 10                push X
 01BF 7C0000            xcall _Timer2_wReadCompareValue
 01C2 62D000            mov REG[0xd0],>__r0
 01C5 5A00              mov [__r0],X
 01C7 20                pop X
 01C8 08                push A
 01C9 5100              mov A,[__r0]
 01CB 62D000            mov REG[0xd0],>_CapturePosEdge2
 01CE 5300              mov [_CapturePosEdge2],A
 01D0 18                pop A
 01D1 5301              mov [_CapturePosEdge2+1],A
 01D3                   .dbline 205
 01D3           ;       
 01D3           ;       // Change the capture to negative edge and set flag
 01D3           ;       Timer2_FUNC_LSB_REG |= 0x80;//0x80
 01D3 7110              or F,0x10  ; iopage = 1
 01D5 432880            or REG[0x28],-128
 01D8                   .dbline 206
 01D8           ;       Flags2 |= FALLING_EDGE2;
 01D8 70CF              and F,0xCF      ; iopage = 0
 01DA 62D000            mov REG[0xd0],>_Flags2
 01DD 2E0002            or [_Flags2],2
 01E0                   .dbline 207
 01E0           ;    }
 01E0           L10:
 01E0                   .dbline -2
 01E0           L8:
 01E0 62D000            mov REG[0xD0],>__r0
 01E3 18                pop A
 01E4 5300              mov [__rZ],A
 01E6 18                pop A
 01E7 5300              mov [__rY],A
 01E9 18                pop A
 01EA 5300              mov [__rX],A
 01EC 18                pop A
 01ED 5300              mov [__r11],A
 01EF 18                pop A
 01F0 5300              mov [__r10],A
 01F2 18                pop A
 01F3 5300              mov [__r9],A
 01F5 18                pop A
 01F6 5300              mov [__r8],A
 01F8 18                pop A
 01F9 5300              mov [__r7],A
 01FB 18                pop A
 01FC 5300              mov [__r6],A
 01FE 18                pop A
 01FF 5300              mov [__r5],A
 0201 18                pop A
 0202 5300              mov [__r4],A
 0204 18                pop A
 0205 5300              mov [__r3],A
 0207 18                pop A
 0208 5300              mov [__r2],A
 020A 18                pop A
 020B 5300              mov [__r1],A
 020D 18                pop A
 020E 5300              mov [__r0],A
 0210 18                pop A
 0211 60D5              mov REG[213],A
 0213 18                pop A
 0214 60D4              mov REG[212],A
 0216 18                pop A
 0217 60D3              mov REG[211],A
 0219 18                pop A
 021A 60D0              mov REG[208],A
 021C 18                pop A
 021D                   .dbline 0 ; func end
 021D 7E                reti
 021E                   .dbend
 021E                   .dbfunc e Timer3CaptureISR _Timer3CaptureISR fV
 021E           _Timer3CaptureISR::
 021E                   .dbline -1
 021E 71C0              or F,-64
 0220 08                push A
 0221 5DD0              mov A,REG[0xd0]
 0223 08                push A
 0224 5DD3              mov A,REG[0xd3]
 0226 08                push A
 0227 5DD4              mov A,REG[0xd4]
 0229 08                push A
 022A 5DD5              mov A,REG[0xd5]
 022C 08                push A
 022D 62D000            mov REG[0xd0],>__r0
 0230 5100              mov A,[__r0]
 0232 08                push A
 0233 5100              mov A,[__r1]
 0235 08                push A
 0236 5100              mov A,[__r2]
 0238 08                push A
 0239 5100              mov A,[__r3]
 023B 08                push A
 023C 5100              mov A,[__r4]
 023E 08                push A
 023F 5100              mov A,[__r5]
 0241 08                push A
 0242 5100              mov A,[__r6]
 0244 08                push A
 0245 5100              mov A,[__r7]
 0247 08                push A
 0248 5100              mov A,[__r8]
 024A 08                push A
 024B 5100              mov A,[__r9]
 024D 08                push A
 024E 5100              mov A,[__r10]
 0250 08                push A
 0251 5100              mov A,[__r11]
 0253 08                push A
 0254 5100              mov A,[__rX]
 0256 08                push A
 0257 5100              mov A,[__rY]
 0259 08                push A
 025A 5100              mov A,[__rZ]
 025C 08                push A
 025D                   .dbline 211
 025D           ; }
 025D           ; 
 025D           ; void Timer3CaptureISR(void)
 025D           ; {
 025D                   .dbline 212
 025D           ;    if(Flags3 & FALLING_EDGE3)
 025D 62D000            mov REG[0xd0],>_Flags3
 0260 470002            tst [_Flags3],2
 0263 A04F              jz L12
 0265                   .dbline 215
 0265           ;    {
 0265           ;       // Read the count on negative edge
 0265           ;       CaptureNegEdge3 = Timer3_wReadCompareValue();
 0265                   .dbline 215
 0265 10                push X
 0266 7C0000            xcall _Timer3_wReadCompareValue
 0269 62D000            mov REG[0xd0],>__r0
 026C 5A00              mov [__r0],X
 026E 20                pop X
 026F 08                push A
 0270 5100              mov A,[__r0]
 0272 62D000            mov REG[0xd0],>_CaptureNegEdge3
 0275 5300              mov [_CaptureNegEdge3],A
 0277 18                pop A
 0278 5301              mov [_CaptureNegEdge3+1],A
 027A                   .dbline 218
 027A           ; 
 027A           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 027A           ;       Timer3_FUNC_LSB_REG &= ~0x80;
 027A 7110              or F,0x10  ; iopage = 1
 027C 41307F            and REG[0x30],127
 027F                   .dbline 219
 027F           ;       Flags3 &= ~FALLING_EDGE3;
 027F 70CF              and F,0xCF      ; iopage = 0
 0281 62D000            mov REG[0xd0],>_Flags3
 0284 2600FD            and [_Flags3],-3
 0287                   .dbline 226
 0287           ; 
 0287           ;       // Calculate the pulswidth by finding difference between positive edge
 0287           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 0287           ;       // the result will be correct even if there is an underflow in the counter
 0287           ;       // The result will be accurate as long as the total pulsewidth is less than
 0287           ;       // 65535 timer ticks.
 0287           ;       PulseWidth3 = CapturePosEdge3 - CaptureNegEdge3;
 0287 62D000            mov REG[0xd0],>_CapturePosEdge3
 028A 5101              mov A,[_CapturePosEdge3+1]
 028C 62D000            mov REG[0xd0],>_CaptureNegEdge3
 028F 1201              sub A,[_CaptureNegEdge3+1]
 0291 62D000            mov REG[0xd0],>_PulseWidth3
 0294 5301              mov [_PulseWidth3+1],A
 0296 62D000            mov REG[0xd0],>_CapturePosEdge3
 0299 5100              mov A,[_CapturePosEdge3]
 029B 62D000            mov REG[0xd0],>_CaptureNegEdge3
 029E 1A00              sbb A,[_CaptureNegEdge3]
 02A0 62D000            mov REG[0xd0],>_PulseWidth3
 02A3 5300              mov [_PulseWidth3],A
 02A5                   .dbline 229
 02A5           ;       
 02A5           ;       // Set the Data available flag
 02A5           ;       Flags3 |= DATA_AVAILABLE3;
 02A5 62D000            mov REG[0xd0],>_Flags3
 02A8 2E0001            or [_Flags3],1
 02AB                   .dbline 230
 02AB           ;         done = TRUE ;// 
 02AB 62D000            mov REG[0xd0],>_done
 02AE 550001            mov [_done],1
 02B1                   .dbline 231
 02B1           ;    }
 02B1 8023              xjmp L13
 02B3           L12:
 02B3                   .dbline 233
 02B3           ;    else
 02B3           ;    {
 02B3                   .dbline 235
 02B3           ;       // Read the count on positive edge
 02B3           ;       CapturePosEdge3 = Timer3_wReadCompareValue();
 02B3 10                push X
 02B4 7C0000            xcall _Timer3_wReadCompareValue
 02B7 62D000            mov REG[0xd0],>__r0
 02BA 5A00              mov [__r0],X
 02BC 20                pop X
 02BD 08                push A
 02BE 5100              mov A,[__r0]
 02C0 62D000            mov REG[0xd0],>_CapturePosEdge3
 02C3 5300              mov [_CapturePosEdge3],A
 02C5 18                pop A
 02C6 5301              mov [_CapturePosEdge3+1],A
 02C8                   .dbline 238
 02C8           ;       
 02C8           ;       // Change the capture to negative edge and set flag
 02C8           ;       Timer3_FUNC_LSB_REG |= 0x80;
 02C8 7110              or F,0x10  ; iopage = 1
 02CA 433080            or REG[0x30],-128
 02CD                   .dbline 239
 02CD           ;       Flags3 |= FALLING_EDGE3;
 02CD 70CF              and F,0xCF      ; iopage = 0
 02CF 62D000            mov REG[0xd0],>_Flags3
 02D2 2E0002            or [_Flags3],2
 02D5                   .dbline 240
 02D5           ;    }
 02D5           L13:
 02D5                   .dbline -2
 02D5           L11:
 02D5 62D000            mov REG[0xD0],>__r0
 02D8 18                pop A
 02D9 5300              mov [__rZ],A
 02DB 18                pop A
 02DC 5300              mov [__rY],A
 02DE 18                pop A
 02DF 5300              mov [__rX],A
 02E1 18                pop A
 02E2 5300              mov [__r11],A
 02E4 18                pop A
 02E5 5300              mov [__r10],A
 02E7 18                pop A
 02E8 5300              mov [__r9],A
 02EA 18                pop A
 02EB 5300              mov [__r8],A
 02ED 18                pop A
 02EE 5300              mov [__r7],A
 02F0 18                pop A
 02F1 5300              mov [__r6],A
 02F3 18                pop A
 02F4 5300              mov [__r5],A
 02F6 18                pop A
 02F7 5300              mov [__r4],A
 02F9 18                pop A
 02FA 5300              mov [__r3],A
 02FC 18                pop A
 02FD 5300              mov [__r2],A
 02FF 18                pop A
 0300 5300              mov [__r1],A
 0302 18                pop A
 0303 5300              mov [__r0],A
 0305 18                pop A
 0306 60D5              mov REG[213],A
 0308 18                pop A
 0309 60D4              mov REG[212],A
 030B 18                pop A
 030C 60D3              mov REG[211],A
 030E 18                pop A
 030F 60D0              mov REG[208],A
 0311 18                pop A
 0312                   .dbline 0 ; func end
 0312 7E                reti
 0313                   .dbend
 0313                   .dbfunc e motorControll1 _motorControll1 fV
 0313           _motorControll1::
 0313                   .dbline -1
 0313                   .dbline 244
 0313           ; }
 0313           ; 
 0313           ; void motorControll1(void)//long OutputDistance
 0313           ; {
 0313                   .dbline 247
 0313           ;                       
 0313           ;          // Check if pulsewidth data is available
 0313           ;     if(Flags & DATA_AVAILABLE)
 0313 62D000            mov REG[0xd0],>_Flags
 0316 470001            tst [_Flags],1
 0319 A01C              jz L15
 031B                   .dbline 249
 031B           ;    {
 031B           ;          LCD_Position(0,0);
 031B                   .dbline 249
 031B 10                push X
 031C 5000              mov A,0
 031E 5700              mov X,0
 0320 7C0000            xcall _LCD_Position
 0323                   .dbline 250
 0323           ;          LCD_PrHexInt(PulseWidth);
 0323 62D000            mov REG[0xd0],>_PulseWidth
 0326 5100              mov A,[_PulseWidth]
 0328 08                push A
 0329 5101              mov A,[_PulseWidth+1]
 032B 20                pop X
 032C 7C0000            xcall _LCD_PrHexInt
 032F 20                pop X
 0330                   .dbline 251
 0330           ;                Flags &= ~DATA_AVAILABLE;
 0330 62D000            mov REG[0xd0],>_Flags
 0333 2600FE            and [_Flags],-2
 0336                   .dbline 254
 0336           ;                       
 0336           ;                       
 0336           ;       }
 0336           L15:
 0336                   .dbline -2
 0336           L14:
 0336                   .dbline 0 ; func end
 0336 7F                ret
 0337                   .dbend
 0337                   .dbfunc e motorControll2 _motorControll2 fV
 0337           _motorControll2::
 0337                   .dbline -1
 0337                   .dbline 261
 0337           ;    
 0337           ;        
 0337           ;       
 0337           ; }
 0337           ; 
 0337           ; void motorControll2(void)// long OutputDistance
 0337           ; {
 0337                   .dbline 262
 0337           ;       if(Flags2 & DATA_AVAILABLE2)
 0337 62D000            mov REG[0xd0],>_Flags2
 033A 470001            tst [_Flags2],1
 033D A01C              jz L18
 033F                   .dbline 264
 033F           ;       {
 033F           ;                LCD_Position(5,0);
 033F                   .dbline 264
 033F 10                push X
 0340 5700              mov X,0
 0342 5005              mov A,5
 0344 7C0000            xcall _LCD_Position
 0347                   .dbline 265
 0347           ;          LCD_PrHexInt(PulseWidth2);
 0347 62D000            mov REG[0xd0],>_PulseWidth2
 034A 5100              mov A,[_PulseWidth2]
 034C 08                push A
 034D 5101              mov A,[_PulseWidth2+1]
 034F 20                pop X
 0350 7C0000            xcall _LCD_PrHexInt
 0353 20                pop X
 0354                   .dbline 267
 0354           ;        
 0354           ;          Flags2 &= ~DATA_AVAILABLE2;
 0354 62D000            mov REG[0xd0],>_Flags2
 0357 2600FE            and [_Flags2],-2
 035A                   .dbline 268
 035A           ;       }
 035A           L18:
 035A                   .dbline -2
 035A           L17:
 035A                   .dbline 0 ; func end
 035A 7F                ret
 035B                   .dbend
 035B                   .dbfunc e ultrasoonSensor _ultrasoonSensor fV
 035B           ;       distance -> X+0
 035B           _ultrasoonSensor::
 035B                   .dbline -1
 035B 10                push X
 035C 4F                mov X,SP
 035D 3804              add SP,4
 035F                   .dbline 275
 035F           ;        
 035F           ;       
 035F           ; }
 035F           ; 
 035F           ; 
 035F           ; void ultrasoonSensor(void)
 035F           ; {
 035F                   .dbline 279
 035F           ;       long distance;
 035F           ;       //this if statmend ensure's the trig pin is trigerd when needed
 035F           ;       
 035F           ;    if(done == FALSE)
 035F 62D000            mov REG[0xd0],>_done
 0362 3C0000            cmp [_done],0
 0365 B019              jnz L21
 0367                   .dbline 281
 0367           ;       {
 0367           ;               PRT1DR |= 0x01;
 0367                   .dbline 281
 0367 430401            or REG[0x4],1
 036A                   .dbline 282
 036A           ;           asm("nop");
 036A 40                        nop
 036B           
 036B                   .dbline 283
 036B           ;               asm("nop");
 036B 40                        nop
 036C           
 036C                   .dbline 284
 036C           ;               asm("nop");
 036C 40                        nop
 036D           
 036D                   .dbline 285
 036D           ;               asm("nop");
 036D 40                        nop
 036E           
 036E                   .dbline 286
 036E           ;               asm("nop");
 036E 40                        nop
 036F           
 036F                   .dbline 287
 036F           ;               asm("nop");
 036F 40                        nop
 0370           
 0370                   .dbline 288
 0370           ;               asm("nop");
 0370 40                        nop
 0371           
 0371                   .dbline 289
 0371           ;               asm("nop");
 0371 40                        nop
 0372           
 0372                   .dbline 290
 0372           ;               asm("nop");
 0372 40                        nop
 0373           
 0373                   .dbline 291
 0373           ;               asm("nop");
 0373 40                        nop
 0374           
 0374                   .dbline 292
 0374           ;               asm("nop");
 0374 40                        nop
 0375           
 0375                   .dbline 293
 0375           ;               asm("nop");
 0375 40                        nop
 0376           
 0376                   .dbline 294
 0376           ;               asm("nop");
 0376 40                        nop
 0377           
 0377                   .dbline 295
 0377           ;               asm("nop");
 0377 40                        nop
 0378           
 0378                   .dbline 296
 0378           ;               asm("nop");
 0378 40                        nop
 0379           
 0379                   .dbline 297
 0379           ;               asm("nop");
 0379 40                        nop
 037A           
 037A                   .dbline 298
 037A           ;               asm("nop");
 037A 40                        nop
 037B           
 037B                   .dbline 299
 037B           ;               asm("nop");
 037B 40                        nop
 037C           
 037C                   .dbline 300
 037C           ;               PRT1DR &= ~0x01;// pin P1[0]
 037C 4104FE            and REG[0x4],-2
 037F                   .dbline 302
 037F           ; 
 037F           ;       }
 037F           L21:
 037F                   .dbline 303
 037F           ;       if(Flags3 & DATA_AVAILABLE3)// do if databit is set 
 037F 62D000            mov REG[0xd0],>_Flags3
 0382 470001            tst [_Flags3],1
 0385 A022              jz L23
 0387                   .dbline 306
 0387           ;     {
 0387           ;       
 0387           ;                LCD_Position(5,5);
 0387                   .dbline 306
 0387 10                push X
 0388 5005              mov A,5
 038A 5705              mov X,5
 038C 7C0000            xcall _LCD_Position
 038F                   .dbline 307
 038F           ;          LCD_PrHexInt(PulseWidth3);
 038F 62D000            mov REG[0xd0],>_PulseWidth3
 0392 5100              mov A,[_PulseWidth3]
 0394 08                push A
 0395 5101              mov A,[_PulseWidth3+1]
 0397 20                pop X
 0398 7C0000            xcall _LCD_PrHexInt
 039B 20                pop X
 039C                   .dbline 309
 039C           ;        
 039C           ;          Flags3 &= ~DATA_AVAILABLE3;
 039C 62D000            mov REG[0xd0],>_Flags3
 039F 2600FE            and [_Flags3],-2
 03A2                   .dbline 310
 03A2           ;               done = FALSE;
 03A2 62D000            mov REG[0xd0],>_done
 03A5 550000            mov [_done],0
 03A8                   .dbline 311
 03A8           ;     }  
 03A8           L23:
 03A8                   .dbline -2
 03A8           L20:
 03A8 38FC              add SP,-4
 03AA 20                pop X
 03AB                   .dbline 0 ; func end
 03AB 7F                ret
 03AC                   .dbsym l distance 0 L
 03AC                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags3::
 0000 00                .byte 0
 0001                   .dbsym e Flags3 _Flags3 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth3::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth3 _PulseWidth3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge3::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge3 _CaptureNegEdge3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge3::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge3 _CapturePosEdge3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags2::
 0000 00                .byte 0
 0001                   .dbsym e Flags2 _Flags2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth2::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth2 _PulseWidth2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge2::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge2 _CaptureNegEdge2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge2::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge2 _CapturePosEdge2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _done::
 0000 00                .byte 0
 0001                   .dbsym e done _done c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags::
 0000 00                .byte 0
 0001                   .dbsym e Flags _Flags c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth _PulseWidth i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge _CaptureNegEdge i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge _CapturePosEdge i
