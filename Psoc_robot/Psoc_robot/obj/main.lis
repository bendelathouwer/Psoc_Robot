 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 23
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; 
 0000           ; void Motor_Control(void);
 0000           ;  BYTE Current_Fault(void );
 0000           ; #define DATA_AVAILABLE 0x01
 0000           ; #define FALLING_EDGE 0x02
 0000           ; 
 0000           ; WORD CapturePosEdge;
 0000           ; WORD CaptureNegEdge;
 0000           ; WORD PulseWidth;
 0000           ; WORD PWM_New;
 0000           ; WORD Period;
 0000           ; 
 0000           ; BYTE Fault;
 0000           ; BYTE Flags;
 0000           ; 
 0000           ; 
 0000           ; #pragma interrupt_handler TimerCaptureISR
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 25
 0000           ;    // Enable Global Interrupt   
 0000           ;    M8C_EnableGInt;
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 28
 0002           ;    
 0002           ;    // Clear the flags
 0002           ;    Flags = 0;
 0002 62D000            mov REG[0xd0],>_Flags
 0005 550000            mov [_Flags],0
 0008                   .dbline 31
 0008           ;    
 0008           ;    // Start timer and enable interrupt
 0008           ;    Timer_Start();
 0008 10                push X
 0009 7C0000            xcall _Timer_Start
 000C                   .dbline 32
 000C           ;    Timer_EnableInt();
 000C 7C0000            xcall _Timer_EnableInt
 000F                   .dbline 36
 000F           ;    
 000F           ;    // Start LCD and PWM.  The PWM generates a test signal
 000F           ;         
 000F           ;       PWM_WritePulseWidth(PulseWidth);
 000F 62D000            mov REG[0xd0],>_PulseWidth
 0012 5100              mov A,[_PulseWidth]
 0014 08                push A
 0015 5101              mov A,[_PulseWidth+1]
 0017 20                pop X
 0018 7C0000            xcall _PWM_WritePulseWidth
 001B                   .dbline 37
 001B           ;       PWM_Start();
 001B 7C0000            xcall _PWM_Start
 001E                   .dbline 38
 001E           ;       LCD_Start();
 001E 7C0000            xcall _LCD_Start
 0021                   .dbline 39
 0021           ;       LCD_Position(1,0);
 0021 5700              mov X,0
 0023 5001              mov A,1
 0025 7C0000            xcall _LCD_Position
 0028                   .dbline 40
 0028           ;       LCD_PrCString("Beta Test 0.0");
 0028 5000              mov A,>L2
 002A 08                push A
 002B 5000              mov A,<L2
 002D 5C                mov X,A
 002E 18                pop A
 002F 7C0000            xcall _LCD_PrCString
 0032 20                pop X
 0033                   .dbline 41
 0033           ;       PRT1DR = 0x80;
 0033 620480            mov REG[0x4],-128
 0036 8003              xjmp L4
 0038           L3:
 0038                   .dbline 43
 0038           ;    while(1)
 0038           ;    {
 0038                   .dbline 44
 0038           ;               Motor_Control();
 0038 9100              xcall _Motor_Control
 003A                   .dbline 45
 003A           ;    }
 003A           L4:
 003A                   .dbline 42
 003A 8FFD              xjmp L3
 003C           X0:
 003C                   .dbline -2
 003C           L1:
 003C                   .dbline 0 ; func end
 003C 8FFF              jmp .
 003E                   .dbend
 003E                   .dbfunc e TimerCaptureISR _TimerCaptureISR fV
 003E           _TimerCaptureISR::
 003E                   .dbline -1
 003E 71C0              or F,-64
 0040 08                push A
 0041 5DD0              mov A,REG[0xd0]
 0043 08                push A
 0044 5DD3              mov A,REG[0xd3]
 0046 08                push A
 0047 5DD4              mov A,REG[0xd4]
 0049 08                push A
 004A 5DD5              mov A,REG[0xd5]
 004C 08                push A
 004D 62D000            mov REG[0xd0],>__r0
 0050 5100              mov A,[__r0]
 0052 08                push A
 0053 5100              mov A,[__r1]
 0055 08                push A
 0056 5100              mov A,[__r2]
 0058 08                push A
 0059 5100              mov A,[__r3]
 005B 08                push A
 005C 5100              mov A,[__r4]
 005E 08                push A
 005F 5100              mov A,[__r5]
 0061 08                push A
 0062 5100              mov A,[__r6]
 0064 08                push A
 0065 5100              mov A,[__r7]
 0067 08                push A
 0068 5100              mov A,[__r8]
 006A 08                push A
 006B 5100              mov A,[__r9]
 006D 08                push A
 006E 5100              mov A,[__r10]
 0070 08                push A
 0071 5100              mov A,[__r11]
 0073 08                push A
 0074 5100              mov A,[__rX]
 0076 08                push A
 0077 5100              mov A,[__rY]
 0079 08                push A
 007A 5100              mov A,[__rZ]
 007C 08                push A
 007D                   .dbline 49
 007D           ; }
 007D           ; 
 007D           ; void TimerCaptureISR(void)
 007D           ; {
 007D                   .dbline 50
 007D           ;    if(Flags & FALLING_EDGE)
 007D 62D000            mov REG[0xd0],>_Flags
 0080 470002            tst [_Flags],2
 0083 A049              jz L7
 0085                   .dbline 53
 0085           ;    {
 0085           ;       // Read the count on negative edge
 0085           ;       CaptureNegEdge = Timer_wReadCompareValue();
 0085                   .dbline 53
 0085 10                push X
 0086 7C0000            xcall _Timer_wReadCompareValue
 0089 62D000            mov REG[0xd0],>__r0
 008C 5A00              mov [__r0],X
 008E 20                pop X
 008F 08                push A
 0090 5100              mov A,[__r0]
 0092 62D000            mov REG[0xd0],>_CaptureNegEdge
 0095 5300              mov [_CaptureNegEdge],A
 0097 18                pop A
 0098 5301              mov [_CaptureNegEdge+1],A
 009A                   .dbline 56
 009A           ; 
 009A           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 009A           ;       Timer_FUNC_LSB_REG &= ~0x80;
 009A 7110              or F,0x10  ; iopage = 1
 009C 41207F            and REG[0x20],127
 009F                   .dbline 57
 009F           ;       Flags &= ~FALLING_EDGE;
 009F 70CF              and F,0xCF      ; iopage = 0
 00A1 62D000            mov REG[0xd0],>_Flags
 00A4 2600FD            and [_Flags],-3
 00A7                   .dbline 64
 00A7           ; 
 00A7           ;       // Calculate the pulswidth by finding difference between positive edge
 00A7           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 00A7           ;       // the result will be correct even if there is an underflow in the counter
 00A7           ;       // The result will be accurate as long as the total pulsewidth is less than
 00A7           ;       // 65535 timer ticks.
 00A7           ;       PulseWidth = CapturePosEdge - CaptureNegEdge;
 00A7 62D000            mov REG[0xd0],>_CapturePosEdge
 00AA 5101              mov A,[_CapturePosEdge+1]
 00AC 62D000            mov REG[0xd0],>_CaptureNegEdge
 00AF 1201              sub A,[_CaptureNegEdge+1]
 00B1 62D000            mov REG[0xd0],>_PulseWidth
 00B4 5301              mov [_PulseWidth+1],A
 00B6 62D000            mov REG[0xd0],>_CapturePosEdge
 00B9 5100              mov A,[_CapturePosEdge]
 00BB 62D000            mov REG[0xd0],>_CaptureNegEdge
 00BE 1A00              sbb A,[_CaptureNegEdge]
 00C0 62D000            mov REG[0xd0],>_PulseWidth
 00C3 5300              mov [_PulseWidth],A
 00C5                   .dbline 67
 00C5           ;       
 00C5           ;       // Set the Data available flag
 00C5           ;       Flags |= DATA_AVAILABLE;
 00C5 62D000            mov REG[0xd0],>_Flags
 00C8 2E0001            or [_Flags],1
 00CB                   .dbline 68
 00CB           ;    }
 00CB 8023              xjmp L8
 00CD           L7:
 00CD                   .dbline 70
 00CD           ;    else
 00CD           ;    {
 00CD                   .dbline 72
 00CD           ;       // Read the count on positive edge
 00CD           ;       CapturePosEdge = Timer_wReadCompareValue();
 00CD 10                push X
 00CE 7C0000            xcall _Timer_wReadCompareValue
 00D1 62D000            mov REG[0xd0],>__r0
 00D4 5A00              mov [__r0],X
 00D6 20                pop X
 00D7 08                push A
 00D8 5100              mov A,[__r0]
 00DA 62D000            mov REG[0xd0],>_CapturePosEdge
 00DD 5300              mov [_CapturePosEdge],A
 00DF 18                pop A
 00E0 5301              mov [_CapturePosEdge+1],A
 00E2                   .dbline 75
 00E2           ;       
 00E2           ;       // Change the capture to negative edge and set flag
 00E2           ;       Timer_FUNC_LSB_REG |= 0x80;
 00E2 7110              or F,0x10  ; iopage = 1
 00E4 432080            or REG[0x20],-128
 00E7                   .dbline 76
 00E7           ;       Flags |= FALLING_EDGE;
 00E7 70CF              and F,0xCF      ; iopage = 0
 00E9 62D000            mov REG[0xd0],>_Flags
 00EC 2E0002            or [_Flags],2
 00EF                   .dbline 77
 00EF           ;    }
 00EF           L8:
 00EF                   .dbline -2
 00EF           L6:
 00EF 62D000            mov REG[0xD0],>__r0
 00F2 18                pop A
 00F3 5300              mov [__rZ],A
 00F5 18                pop A
 00F6 5300              mov [__rY],A
 00F8 18                pop A
 00F9 5300              mov [__rX],A
 00FB 18                pop A
 00FC 5300              mov [__r11],A
 00FE 18                pop A
 00FF 5300              mov [__r10],A
 0101 18                pop A
 0102 5300              mov [__r9],A
 0104 18                pop A
 0105 5300              mov [__r8],A
 0107 18                pop A
 0108 5300              mov [__r7],A
 010A 18                pop A
 010B 5300              mov [__r6],A
 010D 18                pop A
 010E 5300              mov [__r5],A
 0110 18                pop A
 0111 5300              mov [__r4],A
 0113 18                pop A
 0114 5300              mov [__r3],A
 0116 18                pop A
 0117 5300              mov [__r2],A
 0119 18                pop A
 011A 5300              mov [__r1],A
 011C 18                pop A
 011D 5300              mov [__r0],A
 011F 18                pop A
 0120 60D5              mov REG[213],A
 0122 18                pop A
 0123 60D4              mov REG[212],A
 0125 18                pop A
 0126 60D3              mov REG[211],A
 0128 18                pop A
 0129 60D0              mov REG[208],A
 012B 18                pop A
 012C                   .dbline 0 ; func end
 012C 7E                reti
 012D                   .dbend
 012D                   .dbfunc e Current_Fault _Current_Fault fc
 012D           ; Fault_Condition -> X+0
 012D           _Current_Fault::
 012D                   .dbline -1
 012D 10                push X
 012E 4F                mov X,SP
 012F 3801              add SP,1
 0131                   .dbline 81
 0131           ; }
 0131           ; 
 0131           ; BYTE Current_Fault(void)
 0131           ; {
 0131                   .dbline 83
 0131           ;       BYTE Fault_Condition;
 0131           ;       return Fault_Condition;
 0131 5200              mov A,[X+0]
 0133 62D000            mov REG[0xd0],>__r0
 0136                   .dbline -2
 0136           L9:
 0136 38FF              add SP,-1
 0138 20                pop X
 0139                   .dbline 0 ; func end
 0139 7F                ret
 013A                   .dbsym l Fault_Condition 0 c
 013A                   .dbend
 013A                   .dbfunc e Motor_Control _Motor_Control fV
 013A           _Motor_Control::
 013A                   .dbline -1
 013A                   .dbline 87
 013A           ; }
 013A           ; 
 013A           ; void Motor_Control(void)
 013A           ; {
 013A                   .dbline 88
 013A           ;       {
 013A                   .dbline 90
 013A           ;       // Check if pulsewidth data is available
 013A           ;       if(Flags & DATA_AVAILABLE)
 013A 62D000            mov REG[0xd0],>_Flags
 013D 470001            tst [_Flags],1
 0140 A062              jz L11
 0142                   .dbline 94
 0142           ;       {
 0142           ;          // Print the pulsewidth on the LCD
 0142           ;         
 0142           ;                LCD_Position(0,0);
 0142                   .dbline 94
 0142 10                push X
 0143 5000              mov A,0
 0145 5700              mov X,0
 0147 7C0000            xcall _LCD_Position
 014A                   .dbline 96
 014A           ;        // stick to te left  hex 00BF(dec 191 )stick to the right Hex 0073(dec 115) stick midel Hex 009A(dec 154)
 014A           ;                LCD_PrHexInt(PulseWidth);
 014A 62D000            mov REG[0xd0],>_PulseWidth
 014D 5100              mov A,[_PulseWidth]
 014F 08                push A
 0150 5101              mov A,[_PulseWidth+1]
 0152 20                pop X
 0153 7C0000            xcall _LCD_PrHexInt
 0156 20                pop X
 0157                   .dbline 97
 0157           ;          Flags &= ~DATA_AVAILABLE;
 0157 62D000            mov REG[0xd0],>_Flags
 015A 2600FE            and [_Flags],-2
 015D                   .dbline 98
 015D           ;               PWM_New = PulseWidth;
 015D 62D000            mov REG[0xd0],>_PulseWidth
 0160 5101              mov A,[_PulseWidth+1]
 0162 08                push A
 0163 5100              mov A,[_PulseWidth]
 0165 62D000            mov REG[0xd0],>_PWM_New
 0168 5300              mov [_PWM_New],A
 016A 18                pop A
 016B 5301              mov [_PWM_New+1],A
 016D                   .dbline 99
 016D           ;               Period = 5100; 
 016D 62D000            mov REG[0xd0],>_Period
 0170 5501EC            mov [_Period+1],-20
 0173 550013            mov [_Period],19
 0176                   .dbline 100
 0176           ;               PWM_WritePeriod(Period);
 0176 10                push X
 0177 5100              mov A,[_Period]
 0179 08                push A
 017A 5101              mov A,[_Period+1]
 017C 20                pop X
 017D 7C0000            xcall _PWM_WritePeriod
 0180                   .dbline 101
 0180           ;               PWM_WritePulseWidth(PWM_New);
 0180 62D000            mov REG[0xd0],>_PWM_New
 0183 5100              mov A,[_PWM_New]
 0185 08                push A
 0186 5101              mov A,[_PWM_New+1]
 0188 20                pop X
 0189 7C0000            xcall _PWM_WritePulseWidth
 018C                   .dbline 102
 018C           ;               PWM_Start();
 018C 7C0000            xcall _PWM_Start
 018F                   .dbline 103
 018F           ;                LCD_Position(5,0);
 018F 5700              mov X,0
 0191 5005              mov A,5
 0193 7C0000            xcall _LCD_Position
 0196                   .dbline 104
 0196           ;                LCD_PrHexInt(PWM_New);
 0196 62D000            mov REG[0xd0],>_PWM_New
 0199 5100              mov A,[_PWM_New]
 019B 08                push A
 019C 5101              mov A,[_PWM_New+1]
 019E 20                pop X
 019F 7C0000            xcall _LCD_PrHexInt
 01A2 20                pop X
 01A3                   .dbline 105
 01A3           ;       }
 01A3           L11:
 01A3                   .dbline 106
 01A3           ;    }
 01A3                   .dbline -2
 01A3           L10:
 01A3                   .dbline 0 ; func end
 01A3 7F                ret
 01A4                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags::
 0000 00                .byte 0
 0001                   .dbsym e Flags _Flags c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Fault::
 0000 00                .byte 0
 0001                   .dbsym e Fault _Fault c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Period::
 0000 0000              .byte 0,0
 0002                   .dbsym e Period _Period i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PWM_New::
 0000 0000              .byte 0,0
 0002                   .dbsym e PWM_New _PWM_New i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth _PulseWidth i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge _CaptureNegEdge i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge _CapturePosEdge i
                        .area lit(rom, con, rel, lit)
 0000           L2:
 0000 42657461205465737420302E3000      .byte 'B,'e,'t,'a,32,'T,'e,'s,'t,32,48,46,48,0
