 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 109
 0000           ; //****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; //  FILENAME: main.c
 0000           ; //   Made for project 2 in the second semester of school
 0000           ; //
 0000           ; //  DESCRIPTION: Main file of the Psoc_robot project.
 0000           ; //
 0000           ; //-----------------------------------------------------------------------------
 0000           ; // 
 0000           ; //*****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; ////***************************************************************************************
 0000           ; 
 0000           ; //------------------------------------------------------------------------------
 0000           ; // Name: Psoc_robot
 0000           ; //------------------------------------------------------------------------------
 0000           ; //------------------------------------------------------------------------------
 0000           ; // For Device: CY8C29466
 0000           ; //------------------------------------------------------------------------------
 0000           ; // Required Software:  PSoC Designer 5.3
 0000           ; 
 0000           ; // Project Settings: 
 0000           ; //      
 0000           ; //      Power Setting [Vcc/SysClk Freq]:  5.0V/24MHz
 0000           ; //      CPU Clock:                        Sysclk/1  
 0000           ; //      VC1                               Sysclk/12
 0000           ; //      VC2                               VC1/2 = Sysclk/24
 0000           ; //      
 0000           ; //            Timer:                          `                         For reading one joystick channel      
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareType                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_0
 0000           ; //    Timer2:                         `                         For reading one joystick channel      
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareType                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_1
 0000           ; //    Timer3:                         `                         For reading one joystick channel      
 0000           ; //      Clock                                                            VC2
 0000           ; //      Period                             65535
 0000           ; //      CompareValue                       0
 0000           ; //      CompareType                        Less than or equal to
 0000           ; //      Conected to port                   Port_0_3
 0000           ; //            
 0000           ; //            
 0000           ; //    Pwm conected to port                 Port_0_4
 0000           ; //    PWM:                                                               For contrlling one motor on one side
 0000           ; //      Clock                              VC2
 0000           ; //      Enable                             High
 0000           ; //      Period                             1000
 0000           ; //      PulseWidth                         0
 0000           ; //      CompareType                        Less than 
 0000           ; //      Interrupt Type                     Terminal count
 0000           ; //      LCD:
 0000           ; //      LCDPort                            Port_2
 0000           ; //      
 0000           ; //---------------------------------------------------------------------------------
 0000           ; //   Hardware Connections
 0000           ; // Connect P0.1 to P0.2 and press reset.
 0000           ; // You should note the Value of Pulse Width on the LCD.
 0000           ; //
 0000           ; //---------------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // for timer 1 and motorcontrol 1
 0000           ; #define DATA_AVAILABLE 0x01//staat in de eerste bit van de flag 
 0000           ; #define FALLING_EDGE 0x02 // staat in de 2de bit van de flag 
 0000           ; WORD CapturePosEdge;
 0000           ; WORD CaptureNegEdge;
 0000           ; WORD PulseWidth;
 0000           ; BYTE Flags;
 0000           ; BOOL done;
 0000           ; 
 0000           ; // for timer 2 and motor controll 2
 0000           ; #define DATA_AVAILABLE2 0x01 // new for motorcontroll2
 0000           ; #define FALLING_EDGE2 0x02    // new for motorcontroll2
 0000           ; WORD CapturePosEdge2;// new for motorcontroll2
 0000           ; WORD CaptureNegEdge2;// new for motorcontroll2
 0000           ; WORD PulseWidth2;// new for motorcontroll2
 0000           ; BYTE Flags2;// new for motorcontroll2
 0000           ; 
 0000           ; // for timer 3 and ultrasoon sensor 1
 0000           ; #define DATA_AVAILABLE3 0x01 
 0000           ; #define FALLING_EDGE3 0x02    
 0000           ; #define Set_Distance  50
 0000           ; 
 0000           ; WORD CapturePosEdge3;
 0000           ; WORD CaptureNegEdge3;
 0000           ; WORD PulseWidth3;
 0000           ; BYTE Flags3;
 0000           ; 
 0000           ; void motorControll1(void);//long
 0000           ; void motorControll2(void);
 0000           ; void ultrasoonSensor(void);//long ultrasoon sensor(void);
 0000           ; 
 0000           ; void Pulse(void );
 0000           ; #pragma interrupt_handler TimerCaptureISR// for motorcontroll2
 0000           ; #pragma interrupt_handler Timer2CaptureISR// new for motorcontroll2
 0000           ; #pragma interrupt_handler Timer3CaptureISR
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 111
 0000           ;    // Enable Global Interrupt   
 0000           ;    M8C_EnableGInt;
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 114
 0002           ;    
 0002           ;    // Clear the flags
 0002           ;    Flags = 0;
 0002 62D000            mov REG[0xd0],>_Flags
 0005 550000            mov [_Flags],0
 0008                   .dbline 115
 0008           ;    Flags2 = 0;// new for motorcontroll2
 0008 62D000            mov REG[0xd0],>_Flags2
 000B 550000            mov [_Flags2],0
 000E                   .dbline 118
 000E           ;   
 000E           ;    // Start timers and enable interrupt
 000E           ;    Timer_Start();
 000E 10                push X
 000F 7C0000            xcall _Timer_Start
 0012                   .dbline 119
 0012           ;    Timer2_Start();// new for motorcontroll2
 0012 7C0000            xcall _Timer2_Start
 0015                   .dbline 120
 0015           ;    Timer3_Start();
 0015 7C0000            xcall _Timer3_Start
 0018                   .dbline 121
 0018           ;    Timer_EnableInt();
 0018 7C0000            xcall _Timer_EnableInt
 001B                   .dbline 122
 001B           ;    Timer2_EnableInt();// new for motorcontroll2
 001B 7C0000            xcall _Timer2_EnableInt
 001E                   .dbline 123
 001E           ;    Timer3_EnableInt();
 001E 7C0000            xcall _Timer3_EnableInt
 0021                   .dbline 125
 0021           ;    
 0021           ;    PWM1_Start();      
 0021 7C0000            xcall _PWM1_Start
 0024                   .dbline 126
 0024           ;    LCD_Start();
 0024 7C0000            xcall _LCD_Start
 0027 20                pop X
 0028                   .dbline 127
 0028           ;    PRT1DR = 0x80;// wat is dit ? set  pin to output
 0028 620480            mov REG[0x4],-128
 002B 800B              xjmp L3
 002D           L2:
 002D                   .dbline 130
 002D           ; 
 002D           ;    while(1)
 002D           ;    {
 002D                   .dbline 132
 002D           ;       //long OutputDistance = ultrasoonSensor();
 002D           ;       ultrasoonSensor();
 002D 9327              xcall _ultrasoonSensor
 002F                   .dbline 133
 002F           ;       Pulse();
 002F 934F              xcall _Pulse
 0031                   .dbline 134
 0031           ;       motorControll1();//OutputDistance
 0031 92DB              xcall _motorControll1
 0033                   .dbline 135
 0033           ;     motorControll2();//OutputDistance
 0033 92FD              xcall _motorControll2
 0035                   .dbline 136
 0035           ;       ultrasoonSensor();
 0035 931F              xcall _ultrasoonSensor
 0037                   .dbline 137
 0037           ;    }
 0037           L3:
 0037                   .dbline 129
 0037 8FF5              xjmp L2
 0039           X0:
 0039                   .dbline -2
 0039           L1:
 0039                   .dbline 0 ; func end
 0039 8FFF              jmp .
 003B                   .dbend
 003B                   .dbfunc e TimerCaptureISR _TimerCaptureISR fV
 003B           _TimerCaptureISR::
 003B                   .dbline -1
 003B 71C0              or F,-64
 003D 08                push A
 003E 5DD0              mov A,REG[0xd0]
 0040 08                push A
 0041 5DD3              mov A,REG[0xd3]
 0043 08                push A
 0044 5DD4              mov A,REG[0xd4]
 0046 08                push A
 0047 5DD5              mov A,REG[0xd5]
 0049 08                push A
 004A 62D000            mov REG[0xd0],>__r0
 004D 5100              mov A,[__r0]
 004F 08                push A
 0050 5100              mov A,[__r1]
 0052 08                push A
 0053 5100              mov A,[__r2]
 0055 08                push A
 0056 5100              mov A,[__r3]
 0058 08                push A
 0059 5100              mov A,[__r4]
 005B 08                push A
 005C 5100              mov A,[__r5]
 005E 08                push A
 005F 5100              mov A,[__r6]
 0061 08                push A
 0062 5100              mov A,[__r7]
 0064 08                push A
 0065 5100              mov A,[__r8]
 0067 08                push A
 0068 5100              mov A,[__r9]
 006A 08                push A
 006B 5100              mov A,[__r10]
 006D 08                push A
 006E 5100              mov A,[__r11]
 0070 08                push A
 0071 5100              mov A,[__rX]
 0073 08                push A
 0074 5100              mov A,[__rY]
 0076 08                push A
 0077 5100              mov A,[__rZ]
 0079 08                push A
 007A                   .dbline 141
 007A           ; }
 007A           ; 
 007A           ; void TimerCaptureISR(void)
 007A           ; {
 007A                   .dbline 142
 007A           ;    if(Flags & FALLING_EDGE)
 007A 62D000            mov REG[0xd0],>_Flags
 007D 470002            tst [_Flags],2
 0080 A049              jz L6
 0082                   .dbline 145
 0082           ;    {
 0082           ;       // Read the count on negative edge
 0082           ;       CaptureNegEdge = Timer_wReadCompareValue();
 0082                   .dbline 145
 0082 10                push X
 0083 7C0000            xcall _Timer_wReadCompareValue
 0086 62D000            mov REG[0xd0],>__r0
 0089 5A00              mov [__r0],X
 008B 20                pop X
 008C 08                push A
 008D 5100              mov A,[__r0]
 008F 62D000            mov REG[0xd0],>_CaptureNegEdge
 0092 5300              mov [_CaptureNegEdge],A
 0094 18                pop A
 0095 5301              mov [_CaptureNegEdge+1],A
 0097                   .dbline 148
 0097           ; 
 0097           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 0097           ;       Timer_FUNC_LSB_REG &= ~0x80;
 0097 7110              or F,0x10  ; iopage = 1
 0099 41207F            and REG[0x20],127
 009C                   .dbline 149
 009C           ;       Flags &= ~FALLING_EDGE;
 009C 70CF              and F,0xCF      ; iopage = 0
 009E 62D000            mov REG[0xd0],>_Flags
 00A1 2600FD            and [_Flags],-3
 00A4                   .dbline 156
 00A4           ; 
 00A4           ;       // Calculate the pulswidth by finding difference between positive edge
 00A4           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 00A4           ;       // the result will be correct even if there is an underflow in the counter
 00A4           ;       // The result will be accurate as long as the total pulsewidth is less than
 00A4           ;       // 65535 timer ticks.
 00A4           ;       PulseWidth = CapturePosEdge - CaptureNegEdge;
 00A4 62D000            mov REG[0xd0],>_CapturePosEdge
 00A7 5101              mov A,[_CapturePosEdge+1]
 00A9 62D000            mov REG[0xd0],>_CaptureNegEdge
 00AC 1201              sub A,[_CaptureNegEdge+1]
 00AE 62D000            mov REG[0xd0],>_PulseWidth
 00B1 5301              mov [_PulseWidth+1],A
 00B3 62D000            mov REG[0xd0],>_CapturePosEdge
 00B6 5100              mov A,[_CapturePosEdge]
 00B8 62D000            mov REG[0xd0],>_CaptureNegEdge
 00BB 1A00              sbb A,[_CaptureNegEdge]
 00BD 62D000            mov REG[0xd0],>_PulseWidth
 00C0 5300              mov [_PulseWidth],A
 00C2                   .dbline 159
 00C2           ;       
 00C2           ;       // Set the Data available flag
 00C2           ;       Flags |= DATA_AVAILABLE;
 00C2 62D000            mov REG[0xd0],>_Flags
 00C5 2E0001            or [_Flags],1
 00C8                   .dbline 160
 00C8           ;    }
 00C8 8023              xjmp L7
 00CA           L6:
 00CA                   .dbline 162
 00CA           ;    else
 00CA           ;    {
 00CA                   .dbline 164
 00CA           ;       // Read the count on positive edge
 00CA           ;       CapturePosEdge = Timer_wReadCompareValue();
 00CA 10                push X
 00CB 7C0000            xcall _Timer_wReadCompareValue
 00CE 62D000            mov REG[0xd0],>__r0
 00D1 5A00              mov [__r0],X
 00D3 20                pop X
 00D4 08                push A
 00D5 5100              mov A,[__r0]
 00D7 62D000            mov REG[0xd0],>_CapturePosEdge
 00DA 5300              mov [_CapturePosEdge],A
 00DC 18                pop A
 00DD 5301              mov [_CapturePosEdge+1],A
 00DF                   .dbline 167
 00DF           ;       
 00DF           ;       // Change the capture to negative edge and set flag
 00DF           ;       Timer_FUNC_LSB_REG |= 0x80;
 00DF 7110              or F,0x10  ; iopage = 1
 00E1 432080            or REG[0x20],-128
 00E4                   .dbline 168
 00E4           ;       Flags |= FALLING_EDGE;
 00E4 70CF              and F,0xCF      ; iopage = 0
 00E6 62D000            mov REG[0xd0],>_Flags
 00E9 2E0002            or [_Flags],2
 00EC                   .dbline 169
 00EC           ;    }
 00EC           L7:
 00EC                   .dbline -2
 00EC           L5:
 00EC 62D000            mov REG[0xD0],>__r0
 00EF 18                pop A
 00F0 5300              mov [__rZ],A
 00F2 18                pop A
 00F3 5300              mov [__rY],A
 00F5 18                pop A
 00F6 5300              mov [__rX],A
 00F8 18                pop A
 00F9 5300              mov [__r11],A
 00FB 18                pop A
 00FC 5300              mov [__r10],A
 00FE 18                pop A
 00FF 5300              mov [__r9],A
 0101 18                pop A
 0102 5300              mov [__r8],A
 0104 18                pop A
 0105 5300              mov [__r7],A
 0107 18                pop A
 0108 5300              mov [__r6],A
 010A 18                pop A
 010B 5300              mov [__r5],A
 010D 18                pop A
 010E 5300              mov [__r4],A
 0110 18                pop A
 0111 5300              mov [__r3],A
 0113 18                pop A
 0114 5300              mov [__r2],A
 0116 18                pop A
 0117 5300              mov [__r1],A
 0119 18                pop A
 011A 5300              mov [__r0],A
 011C 18                pop A
 011D 60D5              mov REG[213],A
 011F 18                pop A
 0120 60D4              mov REG[212],A
 0122 18                pop A
 0123 60D3              mov REG[211],A
 0125 18                pop A
 0126 60D0              mov REG[208],A
 0128 18                pop A
 0129                   .dbline 0 ; func end
 0129 7E                reti
 012A                   .dbend
 012A                   .dbfunc e Timer2CaptureISR _Timer2CaptureISR fV
 012A           _Timer2CaptureISR::
 012A                   .dbline -1
 012A 71C0              or F,-64
 012C 08                push A
 012D 5DD0              mov A,REG[0xd0]
 012F 08                push A
 0130 5DD3              mov A,REG[0xd3]
 0132 08                push A
 0133 5DD4              mov A,REG[0xd4]
 0135 08                push A
 0136 5DD5              mov A,REG[0xd5]
 0138 08                push A
 0139 62D000            mov REG[0xd0],>__r0
 013C 5100              mov A,[__r0]
 013E 08                push A
 013F 5100              mov A,[__r1]
 0141 08                push A
 0142 5100              mov A,[__r2]
 0144 08                push A
 0145 5100              mov A,[__r3]
 0147 08                push A
 0148 5100              mov A,[__r4]
 014A 08                push A
 014B 5100              mov A,[__r5]
 014D 08                push A
 014E 5100              mov A,[__r6]
 0150 08                push A
 0151 5100              mov A,[__r7]
 0153 08                push A
 0154 5100              mov A,[__r8]
 0156 08                push A
 0157 5100              mov A,[__r9]
 0159 08                push A
 015A 5100              mov A,[__r10]
 015C 08                push A
 015D 5100              mov A,[__r11]
 015F 08                push A
 0160 5100              mov A,[__rX]
 0162 08                push A
 0163 5100              mov A,[__rY]
 0165 08                push A
 0166 5100              mov A,[__rZ]
 0168 08                push A
 0169                   .dbline 173
 0169           ; }
 0169           ; 
 0169           ; void Timer2CaptureISR(void)// new function for motorcontroll2
 0169           ; {
 0169                   .dbline 174
 0169           ;        if(Flags2 & FALLING_EDGE)//
 0169 62D000            mov REG[0xd0],>_Flags2
 016C 470002            tst [_Flags2],2
 016F A049              jz L9
 0171                   .dbline 177
 0171           ;    {
 0171           ;       // Read the count on negative edge
 0171           ;       CaptureNegEdge2 = Timer2_wReadCompareValue();
 0171                   .dbline 177
 0171 10                push X
 0172 7C0000            xcall _Timer2_wReadCompareValue
 0175 62D000            mov REG[0xd0],>__r0
 0178 5A00              mov [__r0],X
 017A 20                pop X
 017B 08                push A
 017C 5100              mov A,[__r0]
 017E 62D000            mov REG[0xd0],>_CaptureNegEdge2
 0181 5300              mov [_CaptureNegEdge2],A
 0183 18                pop A
 0184 5301              mov [_CaptureNegEdge2+1],A
 0186                   .dbline 180
 0186           ; 
 0186           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 0186           ;       Timer2_FUNC_LSB_REG &= ~0x80;//0x80
 0186 7110              or F,0x10  ; iopage = 1
 0188 41287F            and REG[0x28],127
 018B                   .dbline 181
 018B           ;       Flags2 &= ~FALLING_EDGE2;// clearing faling edge bit in flags
 018B 70CF              and F,0xCF      ; iopage = 0
 018D 62D000            mov REG[0xd0],>_Flags2
 0190 2600FD            and [_Flags2],-3
 0193                   .dbline 189
 0193           ;       
 0193           ; 
 0193           ;       // Calculate the pulswidth by finding difference between positive edge
 0193           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 0193           ;       // the result will be correct even if there is an underflow in the counter
 0193           ;       // The result will be accurate as long as the total pulsewidth is less than
 0193           ;       // 65535 timer ticks.
 0193           ;       PulseWidth2 = CapturePosEdge2 - CaptureNegEdge2;
 0193 62D000            mov REG[0xd0],>_CapturePosEdge2
 0196 5101              mov A,[_CapturePosEdge2+1]
 0198 62D000            mov REG[0xd0],>_CaptureNegEdge2
 019B 1201              sub A,[_CaptureNegEdge2+1]
 019D 62D000            mov REG[0xd0],>_PulseWidth2
 01A0 5301              mov [_PulseWidth2+1],A
 01A2 62D000            mov REG[0xd0],>_CapturePosEdge2
 01A5 5100              mov A,[_CapturePosEdge2]
 01A7 62D000            mov REG[0xd0],>_CaptureNegEdge2
 01AA 1A00              sbb A,[_CaptureNegEdge2]
 01AC 62D000            mov REG[0xd0],>_PulseWidth2
 01AF 5300              mov [_PulseWidth2],A
 01B1                   .dbline 192
 01B1           ;       
 01B1           ;       // Set the Data available flag
 01B1           ;       Flags2 |= DATA_AVAILABLE2;
 01B1 62D000            mov REG[0xd0],>_Flags2
 01B4 2E0001            or [_Flags2],1
 01B7                   .dbline 193
 01B7           ;    }
 01B7 8023              xjmp L10
 01B9           L9:
 01B9                   .dbline 195
 01B9           ;    else
 01B9           ;    {
 01B9                   .dbline 197
 01B9           ;       // Read the count on positive edge
 01B9           ;       CapturePosEdge2 = Timer2_wReadCompareValue();
 01B9 10                push X
 01BA 7C0000            xcall _Timer2_wReadCompareValue
 01BD 62D000            mov REG[0xd0],>__r0
 01C0 5A00              mov [__r0],X
 01C2 20                pop X
 01C3 08                push A
 01C4 5100              mov A,[__r0]
 01C6 62D000            mov REG[0xd0],>_CapturePosEdge2
 01C9 5300              mov [_CapturePosEdge2],A
 01CB 18                pop A
 01CC 5301              mov [_CapturePosEdge2+1],A
 01CE                   .dbline 200
 01CE           ;       
 01CE           ;       // Change the capture to negative edge and set flag
 01CE           ;       Timer2_FUNC_LSB_REG |= 0x80;//0x80
 01CE 7110              or F,0x10  ; iopage = 1
 01D0 432880            or REG[0x28],-128
 01D3                   .dbline 201
 01D3           ;       Flags2 |= FALLING_EDGE2;
 01D3 70CF              and F,0xCF      ; iopage = 0
 01D5 62D000            mov REG[0xd0],>_Flags2
 01D8 2E0002            or [_Flags2],2
 01DB                   .dbline 202
 01DB           ;    }
 01DB           L10:
 01DB                   .dbline -2
 01DB           L8:
 01DB 62D000            mov REG[0xD0],>__r0
 01DE 18                pop A
 01DF 5300              mov [__rZ],A
 01E1 18                pop A
 01E2 5300              mov [__rY],A
 01E4 18                pop A
 01E5 5300              mov [__rX],A
 01E7 18                pop A
 01E8 5300              mov [__r11],A
 01EA 18                pop A
 01EB 5300              mov [__r10],A
 01ED 18                pop A
 01EE 5300              mov [__r9],A
 01F0 18                pop A
 01F1 5300              mov [__r8],A
 01F3 18                pop A
 01F4 5300              mov [__r7],A
 01F6 18                pop A
 01F7 5300              mov [__r6],A
 01F9 18                pop A
 01FA 5300              mov [__r5],A
 01FC 18                pop A
 01FD 5300              mov [__r4],A
 01FF 18                pop A
 0200 5300              mov [__r3],A
 0202 18                pop A
 0203 5300              mov [__r2],A
 0205 18                pop A
 0206 5300              mov [__r1],A
 0208 18                pop A
 0209 5300              mov [__r0],A
 020B 18                pop A
 020C 60D5              mov REG[213],A
 020E 18                pop A
 020F 60D4              mov REG[212],A
 0211 18                pop A
 0212 60D3              mov REG[211],A
 0214 18                pop A
 0215 60D0              mov REG[208],A
 0217 18                pop A
 0218                   .dbline 0 ; func end
 0218 7E                reti
 0219                   .dbend
 0219                   .dbfunc e Timer3CaptureISR _Timer3CaptureISR fV
 0219           _Timer3CaptureISR::
 0219                   .dbline -1
 0219 71C0              or F,-64
 021B 08                push A
 021C 5DD0              mov A,REG[0xd0]
 021E 08                push A
 021F 5DD3              mov A,REG[0xd3]
 0221 08                push A
 0222 5DD4              mov A,REG[0xd4]
 0224 08                push A
 0225 5DD5              mov A,REG[0xd5]
 0227 08                push A
 0228 62D000            mov REG[0xd0],>__r0
 022B 5100              mov A,[__r0]
 022D 08                push A
 022E 5100              mov A,[__r1]
 0230 08                push A
 0231 5100              mov A,[__r2]
 0233 08                push A
 0234 5100              mov A,[__r3]
 0236 08                push A
 0237 5100              mov A,[__r4]
 0239 08                push A
 023A 5100              mov A,[__r5]
 023C 08                push A
 023D 5100              mov A,[__r6]
 023F 08                push A
 0240 5100              mov A,[__r7]
 0242 08                push A
 0243 5100              mov A,[__r8]
 0245 08                push A
 0246 5100              mov A,[__r9]
 0248 08                push A
 0249 5100              mov A,[__r10]
 024B 08                push A
 024C 5100              mov A,[__r11]
 024E 08                push A
 024F 5100              mov A,[__rX]
 0251 08                push A
 0252 5100              mov A,[__rY]
 0254 08                push A
 0255 5100              mov A,[__rZ]
 0257 08                push A
 0258                   .dbline 206
 0258           ; }
 0258           ; 
 0258           ; void Timer3CaptureISR(void)
 0258           ; {
 0258                   .dbline 207
 0258           ;    if(Flags3 & FALLING_EDGE3)
 0258 62D000            mov REG[0xd0],>_Flags3
 025B 470002            tst [_Flags3],2
 025E A04F              jz L12
 0260                   .dbline 210
 0260           ;    {
 0260           ;       // Read the count on negative edge
 0260           ;       CaptureNegEdge3 = Timer3_wReadCompareValue();
 0260                   .dbline 210
 0260 10                push X
 0261 7C0000            xcall _Timer3_wReadCompareValue
 0264 62D000            mov REG[0xd0],>__r0
 0267 5A00              mov [__r0],X
 0269 20                pop X
 026A 08                push A
 026B 5100              mov A,[__r0]
 026D 62D000            mov REG[0xd0],>_CaptureNegEdge3
 0270 5300              mov [_CaptureNegEdge3],A
 0272 18                pop A
 0273 5301              mov [_CaptureNegEdge3+1],A
 0275                   .dbline 213
 0275           ; 
 0275           ;       // Change the capture to positive edge and clear the FALLING_EDGE flag
 0275           ;       Timer3_FUNC_LSB_REG &= ~0x80;
 0275 7110              or F,0x10  ; iopage = 1
 0277 41307F            and REG[0x30],127
 027A                   .dbline 214
 027A           ;       Flags3 &= ~FALLING_EDGE3;
 027A 70CF              and F,0xCF      ; iopage = 0
 027C 62D000            mov REG[0xd0],>_Flags3
 027F 2600FD            and [_Flags3],-3
 0282                   .dbline 221
 0282           ; 
 0282           ;       // Calculate the pulswidth by finding difference between positive edge
 0282           ;       // and negative edge counts.  As both the numbers are unsigned numbers
 0282           ;       // the result will be correct even if there is an underflow in the counter
 0282           ;       // The result will be accurate as long as the total pulsewidth is less than
 0282           ;       // 65535 timer ticks.
 0282           ;       PulseWidth3 = CapturePosEdge3 - CaptureNegEdge3;
 0282 62D000            mov REG[0xd0],>_CapturePosEdge3
 0285 5101              mov A,[_CapturePosEdge3+1]
 0287 62D000            mov REG[0xd0],>_CaptureNegEdge3
 028A 1201              sub A,[_CaptureNegEdge3+1]
 028C 62D000            mov REG[0xd0],>_PulseWidth3
 028F 5301              mov [_PulseWidth3+1],A
 0291 62D000            mov REG[0xd0],>_CapturePosEdge3
 0294 5100              mov A,[_CapturePosEdge3]
 0296 62D000            mov REG[0xd0],>_CaptureNegEdge3
 0299 1A00              sbb A,[_CaptureNegEdge3]
 029B 62D000            mov REG[0xd0],>_PulseWidth3
 029E 5300              mov [_PulseWidth3],A
 02A0                   .dbline 224
 02A0           ;       
 02A0           ;       // Set the Data available flag
 02A0           ;       Flags3 |= DATA_AVAILABLE3;
 02A0 62D000            mov REG[0xd0],>_Flags3
 02A3 2E0001            or [_Flags3],1
 02A6                   .dbline 225
 02A6           ;         done = TRUE ;// 
 02A6 62D000            mov REG[0xd0],>_done
 02A9 550001            mov [_done],1
 02AC                   .dbline 226
 02AC           ;    }
 02AC 8023              xjmp L13
 02AE           L12:
 02AE                   .dbline 228
 02AE           ;    else
 02AE           ;    {
 02AE                   .dbline 230
 02AE           ;       // Read the count on positive edge
 02AE           ;       CapturePosEdge3 = Timer3_wReadCompareValue();
 02AE 10                push X
 02AF 7C0000            xcall _Timer3_wReadCompareValue
 02B2 62D000            mov REG[0xd0],>__r0
 02B5 5A00              mov [__r0],X
 02B7 20                pop X
 02B8 08                push A
 02B9 5100              mov A,[__r0]
 02BB 62D000            mov REG[0xd0],>_CapturePosEdge3
 02BE 5300              mov [_CapturePosEdge3],A
 02C0 18                pop A
 02C1 5301              mov [_CapturePosEdge3+1],A
 02C3                   .dbline 233
 02C3           ;       
 02C3           ;       // Change the capture to negative edge and set flag
 02C3           ;       Timer3_FUNC_LSB_REG |= 0x80;
 02C3 7110              or F,0x10  ; iopage = 1
 02C5 433080            or REG[0x30],-128
 02C8                   .dbline 234
 02C8           ;       Flags3 |= FALLING_EDGE3;
 02C8 70CF              and F,0xCF      ; iopage = 0
 02CA 62D000            mov REG[0xd0],>_Flags3
 02CD 2E0002            or [_Flags3],2
 02D0                   .dbline 235
 02D0           ;    }
 02D0           L13:
 02D0                   .dbline -2
 02D0           L11:
 02D0 62D000            mov REG[0xD0],>__r0
 02D3 18                pop A
 02D4 5300              mov [__rZ],A
 02D6 18                pop A
 02D7 5300              mov [__rY],A
 02D9 18                pop A
 02DA 5300              mov [__rX],A
 02DC 18                pop A
 02DD 5300              mov [__r11],A
 02DF 18                pop A
 02E0 5300              mov [__r10],A
 02E2 18                pop A
 02E3 5300              mov [__r9],A
 02E5 18                pop A
 02E6 5300              mov [__r8],A
 02E8 18                pop A
 02E9 5300              mov [__r7],A
 02EB 18                pop A
 02EC 5300              mov [__r6],A
 02EE 18                pop A
 02EF 5300              mov [__r5],A
 02F1 18                pop A
 02F2 5300              mov [__r4],A
 02F4 18                pop A
 02F5 5300              mov [__r3],A
 02F7 18                pop A
 02F8 5300              mov [__r2],A
 02FA 18                pop A
 02FB 5300              mov [__r1],A
 02FD 18                pop A
 02FE 5300              mov [__r0],A
 0300 18                pop A
 0301 60D5              mov REG[213],A
 0303 18                pop A
 0304 60D4              mov REG[212],A
 0306 18                pop A
 0307 60D3              mov REG[211],A
 0309 18                pop A
 030A 60D0              mov REG[208],A
 030C 18                pop A
 030D                   .dbline 0 ; func end
 030D 7E                reti
 030E                   .dbend
 030E                   .dbfunc e motorControll1 _motorControll1 fV
 030E           _motorControll1::
 030E                   .dbline -1
 030E                   .dbline 239
 030E           ; }
 030E           ; 
 030E           ; void motorControll1(void)//long OutputDistance
 030E           ; {
 030E                   .dbline 242
 030E           ;                       
 030E           ;          // Check if pulsewidth data is available
 030E           ;       if(Flags & DATA_AVAILABLE)
 030E 62D000            mov REG[0xd0],>_Flags
 0311 470001            tst [_Flags],1
 0314 A01C              jz L15
 0316                   .dbline 244
 0316           ;        {
 0316           ;          LCD_Position(0,0);
 0316                   .dbline 244
 0316 10                push X
 0317 5000              mov A,0
 0319 5700              mov X,0
 031B 7C0000            xcall _LCD_Position
 031E                   .dbline 245
 031E           ;          LCD_PrHexInt(PulseWidth);
 031E 62D000            mov REG[0xd0],>_PulseWidth
 0321 5100              mov A,[_PulseWidth]
 0323 08                push A
 0324 5101              mov A,[_PulseWidth+1]
 0326 20                pop X
 0327 7C0000            xcall _LCD_PrHexInt
 032A 20                pop X
 032B                   .dbline 246
 032B           ;                       Flags &= ~DATA_AVAILABLE;
 032B 62D000            mov REG[0xd0],>_Flags
 032E 2600FE            and [_Flags],-2
 0331                   .dbline 247
 0331           ;       }
 0331           L15:
 0331                   .dbline -2
 0331           L14:
 0331                   .dbline 0 ; func end
 0331 7F                ret
 0332                   .dbend
 0332                   .dbfunc e motorControll2 _motorControll2 fV
 0332           _motorControll2::
 0332                   .dbline -1
 0332                   .dbline 254
 0332           ;    
 0332           ;        
 0332           ;       
 0332           ; }
 0332           ; 
 0332           ; void motorControll2(void)// long OutputDistance
 0332           ; {
 0332                   .dbline 255
 0332           ;       if(Flags2 & DATA_AVAILABLE2)
 0332 62D000            mov REG[0xd0],>_Flags2
 0335 470001            tst [_Flags2],1
 0338 A01C              jz L18
 033A                   .dbline 257
 033A           ;       {
 033A           ;                LCD_Position(5,0);
 033A                   .dbline 257
 033A 10                push X
 033B 5700              mov X,0
 033D 5005              mov A,5
 033F 7C0000            xcall _LCD_Position
 0342                   .dbline 258
 0342           ;          LCD_PrHexInt(PulseWidth2);
 0342 62D000            mov REG[0xd0],>_PulseWidth2
 0345 5100              mov A,[_PulseWidth2]
 0347 08                push A
 0348 5101              mov A,[_PulseWidth2+1]
 034A 20                pop X
 034B 7C0000            xcall _LCD_PrHexInt
 034E 20                pop X
 034F                   .dbline 260
 034F           ;        
 034F           ;          Flags2 &= ~DATA_AVAILABLE2;
 034F 62D000            mov REG[0xd0],>_Flags2
 0352 2600FE            and [_Flags2],-2
 0355                   .dbline 261
 0355           ;       }
 0355           L18:
 0355                   .dbline -2
 0355           L17:
 0355                   .dbline 0 ; func end
 0355 7F                ret
 0356                   .dbend
 0356                   .dbfunc e ultrasoonSensor _ultrasoonSensor fV
 0356           _ultrasoonSensor::
 0356                   .dbline -1
 0356                   .dbline 268
 0356           ;        
 0356           ;       
 0356           ; }
 0356           ; 
 0356           ; 
 0356           ; void ultrasoonSensor(void)
 0356           ; {
 0356                   .dbline 296
 0356           ;       //long distance;
 0356           ;       // this if statmend ensure's the trig pin is trigerd when needed
 0356           ;       
 0356           ; //    if(done = FALSE)
 0356           ; //    {
 0356           ; //            PRT1DR |= 0x01;
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            asm("nop");
 0356           ; //            PRT1DR &= ~0x01;
 0356           ; //
 0356           ; //    }
 0356           ;       if(Flags3 & DATA_AVAILABLE3)// do if databit is set 
 0356 62D000            mov REG[0xd0],>_Flags3
 0359 470001            tst [_Flags3],1
 035C A022              jz L21
 035E                   .dbline 299
 035E           ;     {
 035E           ;       
 035E           ;                LCD_Position(5,5);
 035E                   .dbline 299
 035E 10                push X
 035F 5005              mov A,5
 0361 5705              mov X,5
 0363 7C0000            xcall _LCD_Position
 0366                   .dbline 300
 0366           ;          LCD_PrHexInt(PulseWidth3);
 0366 62D000            mov REG[0xd0],>_PulseWidth3
 0369 5100              mov A,[_PulseWidth3]
 036B 08                push A
 036C 5101              mov A,[_PulseWidth3+1]
 036E 20                pop X
 036F 7C0000            xcall _LCD_PrHexInt
 0372 20                pop X
 0373                   .dbline 302
 0373           ;        
 0373           ;          Flags3 &= ~DATA_AVAILABLE3;
 0373 62D000            mov REG[0xd0],>_Flags3
 0376 2600FE            and [_Flags3],-2
 0379                   .dbline 303
 0379           ;               done = FALSE;
 0379 62D000            mov REG[0xd0],>_done
 037C 550000            mov [_done],0
 037F                   .dbline 304
 037F           ;     }  
 037F           L21:
 037F                   .dbline -2
 037F           L20:
 037F                   .dbline 0 ; func end
 037F 7F                ret
 0380                   .dbend
 0380                   .dbfunc e Pulse _Pulse fV
 0380           _Pulse::
 0380                   .dbline -1
 0380                   .dbline 311
 0380           ; 
 0380           ;       
 0380           ;       //return  distance;
 0380           ; }
 0380           ; 
 0380           ; void Pulse(void )
 0380           ; {
 0380                   .dbline 313
 0380           ;       //    if(done = FALSE)
 0380           ;       {
 0380                   .dbline 314
 0380           ;               PRT1DR |= 0x01;
 0380 430401            or REG[0x4],1
 0383                   .dbline 315
 0383           ;       asm("nop");
 0383 40                        nop
 0384           
 0384                   .dbline 316
 0384           ;               asm("nop");
 0384 40                        nop
 0385           
 0385                   .dbline 317
 0385           ;               asm("nop");
 0385 40                        nop
 0386           
 0386                   .dbline 318
 0386           ;               asm("nop");
 0386 40                        nop
 0387           
 0387                   .dbline 319
 0387           ;               asm("nop");
 0387 40                        nop
 0388           
 0388                   .dbline 320
 0388           ;               asm("nop");
 0388 40                        nop
 0389           
 0389                   .dbline 321
 0389           ;               asm("nop");
 0389 40                        nop
 038A           
 038A                   .dbline 322
 038A           ;               asm("nop");
 038A 40                        nop
 038B           
 038B                   .dbline 323
 038B           ;               asm("nop");
 038B 40                        nop
 038C           
 038C                   .dbline 324
 038C           ;               asm("nop");
 038C 40                        nop
 038D           
 038D                   .dbline 325
 038D           ;               asm("nop");
 038D 40                        nop
 038E           
 038E                   .dbline 326
 038E           ;               asm("nop");
 038E 40                        nop
 038F           
 038F                   .dbline 327
 038F           ;               PRT1DR &= ~0x01;
 038F 4104FE            and REG[0x4],-2
 0392                   .dbline 329
 0392           ; 
 0392           ;       }
 0392                   .dbline -2
 0392           L23:
 0392                   .dbline 0 ; func end
 0392 7F                ret
 0393                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags3::
 0000 00                .byte 0
 0001                   .dbsym e Flags3 _Flags3 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth3::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth3 _PulseWidth3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge3::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge3 _CaptureNegEdge3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge3::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge3 _CapturePosEdge3 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags2::
 0000 00                .byte 0
 0001                   .dbsym e Flags2 _Flags2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth2::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth2 _PulseWidth2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge2::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge2 _CaptureNegEdge2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge2::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge2 _CapturePosEdge2 i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _done::
 0000 00                .byte 0
 0001                   .dbsym e done _done c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _Flags::
 0000 00                .byte 0
 0001                   .dbsym e Flags _Flags c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _PulseWidth::
 0000 0000              .byte 0,0
 0002                   .dbsym e PulseWidth _PulseWidth i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CaptureNegEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CaptureNegEdge _CaptureNegEdge i
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Ben\DOCUME~1\GitHub\PSOC_R~1\PSOC_R~1\PSOC_R~1\main.c
 0000           _CapturePosEdge::
 0000 0000              .byte 0,0
 0002                   .dbsym e CapturePosEdge _CapturePosEdge i
